==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\escalation\route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { EscalationService } from "@/services/escalation.service";
import { requireActorUserId } from "@/lib/actor";

export async function POST(req: NextRequest) {
    try {
        // actor is optional for manual trigger; if you want it required, keep requireActorUserId
        const actorUserId = requireActorUserId(req);

        const body = await req.json();
        const threadId = body?.threadId;
        const reason = body?.reason ?? "Manual escalation";

        if (!threadId) throw new Error("threadId is required");

        const thread = await prisma.thread.findUnique({ where: { id: threadId } });
        if (!thread) throw new Error("Thread not found");

        await EscalationService.triggerEscalation({ threadId, reason, actorUserId });

        return NextResponse.json({ ok: true });
    } catch (e: unknown) {
        return NextResponse.json(
            { ok: false, error: e instanceof Error ? e.message : String(e) },
            { status: 400 }
        );
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\drafts\[draftId]\approve\route.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\drafts\[draftId]\discard\route.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\drafts\[draftId]\edit\route.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\drafts\[draftId]\send\route.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\drafts\route.ts
==================================================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { DraftService } from "@/services/draft.service";

export async function POST() {
    const threads = await prisma.thread.findMany({
        where: { processingStatus: "CLASSIFIED" },
        orderBy: { updatedAt: "asc" },
        take: 25,
        select: { id: true },
    });

    for (const t of threads) {
        await DraftService.createDraftForThread(t.id);
    }

    return NextResponse.json({ ok: true, processed: threads.length });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\ingest\route.ts
==================================================
import { NextResponse } from "next/server";
import { IngestionService } from "@/services/ingestion.service";

export async function POST() {
    await IngestionService.runOnce();
    return NextResponse.json({ ok: true });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\poc\route.ts
==================================================
import { NextResponse } from "next/server";
import { createReplyDraft, listInboxMessages, getMessage } from "@/lib/graph";

export async function GET() {
    const inbox = process.env.GRAPH_POC_INBOX;
    if (!inbox) return NextResponse.json({ ok: false, error: "Missing GRAPH_POC_INBOX" }, { status: 500 });

    // 1) list newest messages
    const list = await listInboxMessages(inbox, 5);
    const first = list?.value?.[0];
    if (!first) return NextResponse.json({ ok: true, message: "No messages found in inbox." });

    // 2) fetch full message
    const msg = await getMessage(inbox, first.id);

    // 3) create reply draft (draft-first)
    const draft = await createReplyDraft(
        inbox,
        msg.id,
        `<p>POC Draft (not sent). This is created by the platform for validation.</p>`
    );

    return NextResponse.json({
        ok: true,
        inbox,
        pickedMessage: {
            id: msg.id,
            subject: msg.subject,
            conversationId: msg.conversationId,
            receivedDateTime: msg.receivedDateTime,
        },
        createdDraft: {
            id: draft?.id,
            subject: draft?.subject,
            conversationId: draft?.conversationId,
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\threads\[threadId]\route.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\graph\threads\route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

function parseBool(v: string | null): boolean | undefined {
    if (v === null) return undefined;
    if (v === "true") return true;
    if (v === "false") return false;
    return undefined;
}

export async function GET(req: NextRequest) {
    try {
        const sp = req.nextUrl.searchParams;

        const inboxId = sp.get("inboxId");
        const department = sp.get("department");
        const stage = sp.get("stage");
        const ownerUserId = sp.get("ownerUserId");
        const processingStatus = sp.get("processingStatus");

        const needsReview = parseBool(sp.get("needsReview"));
        const responseRequired = parseBool(sp.get("responseRequired"));
        const slaBreached = parseBool(sp.get("slaBreached"));

        const take = Math.min(Number(sp.get("take") ?? 50), 200);

        const where: Record<string, unknown> = {};
        if (inboxId) where.inboxId = inboxId;
        if (department) where.department = department;
        if (stage) where.stage = stage;
        if (ownerUserId) where.ownerUserId = ownerUserId;
        if (processingStatus) where.processingStatus = processingStatus;
        if (needsReview !== undefined) where.needsReview = needsReview;
        if (responseRequired !== undefined) where.responseRequired = responseRequired;
        if (slaBreached !== undefined) where.slaBreachedAt = slaBreached ? { not: null } : null;

        const items = await prisma.thread.findMany({
            where,
            orderBy: [{ lastMessageAt: "desc" }, { updatedAt: "desc" }],
            take,
            include: {
                inbox: { select: { id: true, key: true, emailAddress: true, isEscalation: true } },
            },
        });

        return NextResponse.json({ ok: true, items });
    } catch (e: unknown) {
        return NextResponse.json(
            { ok: false, error: e instanceof Error ? e.message : String(e) },
            { status: 400 }
        );
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\health\route.ts
==================================================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET() {
    const dbOk = await prisma.user.count().then(() => true).catch(() => false);
    return NextResponse.json({ ok: true, dbOk });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\sla\route.ts
==================================================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET() {
    const now = new Date();

    const breached = await prisma.thread.count({
        where: { slaBreachedAt: { not: null }, processingStatus: { not: "DONE" } },
    });

    const dueSoon = await prisma.thread.findMany({
        where: {
            slaDueAt: { not: null, lte: new Date(now.getTime() + 60 * 60 * 1000) }, // next 1 hour
            slaBreachedAt: null,
            processingStatus: { not: "DONE" },
        },
        orderBy: { slaDueAt: "asc" },
        take: 20,
        select: { id: true, department: true, stage: true, slaDueAt: true, subject: true },
    });

    return NextResponse.json({ ok: true, breached, dueSoon });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\api\stages\route.ts
==================================================
import { NextRequest, NextResponse } from "next/server";
import { requireActorUserId } from "@/lib/actor";
import { StageService } from "@/services/stage.service";

export async function PATCH(req: NextRequest) {
    try {
        const actorUserId = requireActorUserId(req);
        const body = await req.json();

        const threadId = body?.threadId;
        const stage = body?.stage;

        if (!threadId || !stage) throw new Error("threadId and stage are required");

        await StageService.changeStage({ threadId, stage, actorUserId });

        return NextResponse.json({ ok: true });
    } catch (e: unknown) {
        return NextResponse.json(
            { ok: false, error: e instanceof Error ? e.message : String(e) },
            { status: 400 }
        );
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\favicon.ico
==================================================
         (  F          (  n  00     (-  –           ¾F  (                                                           $   ]   º   º   ]   $                                           ò   ÿ   ÿ   ÿ   ÿ   ò                               8   à   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   à   8                  â   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   â              ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡       #   ô   ÿ   ÿOOOÿ®®®ÿ«««ÿ«««ÿ«««ÿ«««ÿ­­­ÿgggÿ   ÿ   ÿ   ô   #   Y   ÿ   ÿ   ÿÿíííÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿ555ÿ   ÿ   ÿ   ÿ   Y   »   ÿ   ÿ   ÿ   ÿkkkÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   »   »   ÿ   ÿ   ÿ   ÿ			ÿÍÍÍÿÿÿÿÿÿÿÿÿäääÿÿ   ÿ   ÿ   ÿ   ÿ   »   Y   ÿ   ÿ   ÿ   ÿ   ÿJJJÿıııÿÿÿÿÿkkkÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Y   #   ô   ÿ   ÿ   ÿ   ÿÿ¶¶¶ÿÕÕÕÿ			ÿ   ÿ   ÿ   ÿ   ÿ   ô   #       ¡   ÿ   ÿ   ÿ   ÿ   ÿ111ÿDDDÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡              â   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   â                  8   à   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   à   8                               ò   ÿ   ÿ   ÿ   ÿ   ò                                           $   ]   º   º   ]   $                                                                                                                                                                                                                                                                                    (       @                                                                               ,   U      è   è      U   ,                                                                                      *   …   Ò   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   Ò   …   *                                                                      –   ó   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ó   –                                                          Q   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   Q                                               r   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   r                                       r   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   r                               O   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   O                          ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ã                      —   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   —               (   õ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ô   '           †   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ888ÿ‹‹‹ÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿ‰‰‰ÿ___ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   †          Ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿîîîÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿSSSÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ô      +   ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿhhhÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ú   +   T   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿËËËÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   T   ‚   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿGGGÿıııÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ      é   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ­­­ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿäääÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   é   é   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ+++ÿóóóÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿjjjÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   é      ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ‹‹‹ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‚   T   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿãããÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿIIIÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   T   +   ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿhhhÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ¯¯¯ÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ú   +      Ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿËËËÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ô          †   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿGGGÿıııÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   †           '   ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ±±±ÿìììÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   õ   (               —   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ333ÿ___ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   —                      ã   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä                          O   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   O                               r   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   r                                       r   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   r                                               Q   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   Q                                                          –   ó   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ó   –                                                                      *   …   Ò   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   Ò   …   *                                                                                      ,   U      è   è      U   ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (   0   `           -                                                                                             	   (   L   j   ³   ø   ÷   ³   j   K   (   	                                                                                                                                          V       Ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   Ø       U                                                                                                                      %   ‹   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   ‹   &                                                                                                      ‹   ï   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ï   ‹                                                                                          Q   Ü   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ü   R                                                                              Š   ş   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ş   Š                                                                     ­   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ­                                                             ¸   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¸                                                     ®   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ®                                              Š   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Š                                       P   ı   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ı   O                                  ß   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ß                              ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                       #   ñ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ñ   #                   Œ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                  ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ$$$ÿhhhÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿPPPÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä              U   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿëëëÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿsssÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   U           ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡       	   Ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ú   	   (   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   (   K   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿªªªÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   L   j   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ)))ÿòòòÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŒŒŒÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   j   ´   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿˆˆˆÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿãããÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ³   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿáááÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿiiiÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿËËËÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   ³   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ´   j   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   j   L   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿªªªÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   K   (   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ)))ÿòòòÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŒŒŒÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   (   	   Ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿˆˆˆÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿãããÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ú   	       ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿáááÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿiiiÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡           U   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   U              ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä                  ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Œ                   #   ñ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ¬¬¬ÿûûûÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ñ   #                       ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ222ÿ}}}ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                              ß   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ß                                  O   ı   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ı   P                                       Š   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Š                                              ®   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ®                                                     ¸   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¸                                                             ­   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ­                                                                     Š   ş   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ş   Š                                                                              R   Ü   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ü   Q                                                                                          ‹   ï   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ï   ‹                                                                                                      &   ‹   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   ‹   %                                                                                                                      U       Ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   Ø       V                                                                                                                                          	   (   K   j   ³   ÷   ø   ³   j   L   (   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ‰PNG

   
IHDR         \r¨f   sRGB ®Îé   8eXIfMM *    ‡i                                D"8s  IDATxí]	°Õ™n”]<QVA–èÄh$	ÊNŒ13*ˆq°ÂdªÄ©I¡ˆ˜D“L2“ª(Î(Ô˜2ÖÄ™ÑG	‹Áq_@å±ˆà†ŠxÈ›ï»Ğ¾{o÷½½ÓııUß{}»OŸå;çÿûôùÏ9İÂ‘d®(Dg Ğ8	èôN º]€î@ hx¥?v 
ÀNà3à=`;ğ6ğ.ğ&°àuâà  ±”6‰P©Ğ½€Á@ÿÃ RÓ PùiZqÊ^DNãà€wp¼
Ø¼ĞXĞhĞ˜Hg@ÀÌ
:Ùâ|ğ5` p"@À'¼É²™s{
ëpü*ğ2ÀŞ…Ä d Ò¯Œ–È|(0ø
0 à“>Kò
³xX¬6 IJÈ ¤C|?$KENØ}Ï“|ŠÂòµáàöh $	2 Ù|/§Â . Nz ’#¼ÃW€eÀ
à5€ã
’ˆÜ¶ˆúà;Ày •¾ ñgàs©h^  IÄÈ DL(¢;¸8 ÒHjg€cH|x 1 ËR"Œa€ïôÓ• GÁÙ@…è9`/`%0è
HÄ@jğ½~,° ÛK
Ÿ,t).ÎèI‘ˆDèT¦Oû)~º°Vìu$b èª›
ĞU%¥7“ƒ¨›ù _É$b 8Aç×À€ßøJö3` 510wQñ?¤øvrğÑá:ü2şKÄ@ ¤øv*{%#í‚AZ€å’^(õÏ=ñ³g \ãÀWƒÛ€É!:àß,`à6ıÏ643:@’c.FÙŸ¤ğùä€u?Ğ<'áİ€ƒ€”_Üvp: É8Q¾›
IñÅ·
p{3ÎóĞkHÈ¢ŒG¡¼•®cñÑ¼
<62&‹
×2uCÁÿàÚòæ•­ßâ¤Tø3Ú
½ê
€›…;î¼”ªd/~m€½.ø’XÆ@{äw.°ğ«d]G•Ú {lKÜàEbœÿı(P©RuMüTÛC›ÒÚÃ
Àdäï])¿Œ_Lmà=Äû=@bœÍ÷K€ÛGUkÙ^œUÓØÆØÖøš)1€È»gÕT¢ÂŠ¯°m`9Ú\Ú®³ÀQşÍ@ØÊÔıâ°–6ğ:ÚÕ^›w¬òï¸E—D¤Á ç	ü5°àºëÄFĞ,ßÜ
ğX"Òd€mğ<€nB~òì@´¸÷µt×tx‹»
ü;ÚfŞ>ñ“ªíI8µˆ»¿8Ó¸C1Ûª$B¸•§e†©İ+ş’jl«ÜEZÃÇ& ©ÊS:â:Š6°möë´ÿ\G1¥ç`¢¨Å!“nl»lÃÆŠÉ^€Q`í·@OcÙSÆÄ@e¸Í·º¹ç¤qbªp•ÿãS†Ä@upšº±FÀD@å¿Ğ“¿º†¦Ğæ2@#À¹ÆõL3 £A’”$H2Ç _h¶FH#rq(íÿOàDƒò¤¬ˆ¨àrunGOWaêbŠ &–SgDñ3ÀEDçto§*Ç¤šú¡Ä9kŠİ~)¿•¡,$Â x¿RŸ1˜vàK áÀ9€DäU(ğw®&LEÒäê©»€S)¹é3ĞY8x8 $.i€(íŒÄK¬Å€YœìğaÈ]­—´À4”ôÇ€	c‰“®Å@3¸fà€ó•4Æ Æ¢„ÿ
Ğ/*bàüş Çş˜$!I€~‡Ø7ÉB*-1`	o Ÿ º	‘$»àÇ¡D‹¾‰”L‰ˆûàòß êJ"’äÀOQ¢Ë)•ö2@#Ğx4‰"$e ¨ø·Iö8’àOiˆ8ø"İ ¼GäŞ8[xÄt<ñ.´´7&‚m&ØR^‹³tq÷ Ø•á.¾§ÅYÅ-2È ½d§ ûã*_Üà&d|j\™W¼b ãôGùö«â*gœ¯ £‘é‡ÄF4ã"IñŠØƒ´/ b1q€NÈğãÀY€Dˆp¼ŒÛ9îãpÑ}w\¯ ó‘Ô¤£“Ó1 j`€èOûŸî­xK=€ÑHñ÷ ÷A“ˆ1
Ÿ#¾
D:U8jÀõıtù©ë$b bA||ØU¼Q¿ü26%ªÌ)1 Šè…_
Àê¢³!~DÙàºæ• ¿à+b >A´Ü:]ÑE$ˆ£50òGDhRÑtèĞÁéİ»wRÉ)ğPÇ ‘èn$‘ 3ÜÖë@bS§Nu–,Yâ´jÕÊ²œç:»¡ôÜ;ÀáÀßó@£`Ç|ã–-[)“'OVıÙÕ†©sFxÚ®“âÛ¥øn}Í›7¯ üü³~ıúÆºº:»ŒÀQ—©J_¤ÎUKj8–q0xğàÆ;v4 Ì=[õhW=¾	İë	¤&·!e5Ë8hÑ¢Eãİwß]¤üüñá‡6öïß_õiW}şSZÚ?	¿/`Ÿ;vlã¾}û2 <±hÑ" »À§ĞAî¹‘¸ÜÕX,ã mÛ¶+V¬(©ü<¹wïŞÆ#F¨^íª×;“ÖşaHğc ûà”)SÊ*¿{aùòåpÊØc89(Ñ^€şö4&E¦ÛoÃ†
®Wü/· uÆ=±^€ş*?{k^·_EíÇÅúúz¹íªgö† UI-‹è{WU*
œ:pû9.tÚ·o(/İºus>ûì3ç‰'^Rg€ßäÚGâÌI_D®‘»åÜ~~½ ¹­{
øúÙ?N0‘7½SêØ.Æ×¸ÿ~?}/y]nA;êØ£‹³ã2 ]ñFOB2C?·_I­÷œ”[Ğ:°:Ú=#ÀOzKé-ã ˆÛÏ£ï%å´®İ?jĞşIÀ®†PÛ¯¤æ{NÊ-hUİÿt•:™œƒ˜øõ ,â ·ŸG×KÊ-hUÛç¢cƒhP7 ÿÎ¡Â˜Á@µn?¿\Ó-¸k×.¹ıˆ2ã:õú ğ`ÙáF„Û=ı-á V·_ÉG¿ç¤Ü‚Vé İõ}¢0 WIù­ªøFºıÊ­öóèsM‡rZÕ8pJ¸QÜ*@OK8ëöó³
rZ¥Ôİ–a, ßûwË ØSéW^y¥Ÿ‡¾.· 5íat7ÔØİ¤üÖTv#İ~7n­àA"¸üòËÕ+´£WøèpMÂÅ/ªhK8ˆÒíçgä´F/^„·«ÅŒÀM{e ì¨èR›|ú)qØë7İt“æ?8'àµ€KùíP~ºıî¹ç°ú\õırÚÑ> Ç·Uk ØeP÷ß|ë^xÇéöó³
‹/V/Àüvòô™¯ôå„ä¢*×pâvûù ¹­Ğ¾ÊŸ]JûË}óˆk8(•ˆÎÅÇÀÄ‰Ñ£GÇ—€OÌmÚ´q,X oúğ”òe.â˜^ ¡QxĞÓßp’tûùõä4^_ƒN—{à†¾øÅyÄ2 †s¤ÛÏÏ Ğ-Ø¹sgµsÛÌĞiêv‘”Z
8
!~PJ?Œc€«ıîºë®À›|Æ] ®Ü½{·³zõê¸“Rüµ1pnãÔàzïí¥º¼tlpû9³fÍrºvíjTæ®¿şzß4*OÊLã‹~•øÑçÔ•3˜ƒ4İ~~¯r­;ÔmêxYŒ+üÀ€€¡¤íöó3 r­;Ômêx“4à÷Å:7]ÕqLš4)U·Ÿ!rú1”êuê6¿ìÕ$Í
À7›®èÀ8ºwïîÌ™3Ç¸|5Ï>?î\zé¥ÍOë·œëÍ†× ğø,ïE›ÅÀŒ3œš•©2¹¹å–[œººº2Wu:E¾‚´›¼^p.H1cJºtû]}õÕB˜uéÔSOu®ºŠ»ÉIc€O¥òÄ%ƒ 
 ÆAZ«ıüüü®kµ ‘ºD?Ç5 Ş@Q×À
 ÿé3Àwê+®¸"ıŒT™ÎSÀUŞ¥à13Àî?ûâ5 M'İ‹úŸ>pûşZµj•~fjÈ
×ˆ×¡Ô‚n©¦±>× ğÿi5D¤[bf íÕ~a‹'·`Xc¹Ÿã -¼1ók¢›½ÿÄI«ıüŞ÷ı®kµ QºÅ¯|ókßMËé(92È@’t°ÉíçÇİ‚X-èL×“a€úN4€“qÜ'$f0@·
@V„nA›Ü˜Yá½L9:â|/^sÇ ú—	¨Ó)0`êj¿°T\wİuZ-–ÄèîÂ¨\ 	@Ñ:¦±cítûùœ{È-èÇRb×û1%× ôI,Y%T‘Ûİ~‡‹rú1”ØõÂCŸ€,¼$–´*Ë€é«ıÊf<à¹0zş¥èhÕFü„û¦ ·Ÿ«ı|â€¯8Z-èCRü—¹Tg× ĞHRf€‹glYí–ª¹sçÊ-–Äp÷Ó'+Ãèî¶mµ_Ø’gÍÍ–îçC¿{ ô	òÃ’”ÈªÛÏÎ™3gÊ-èGR|×¹7`G€Şñ¥¡˜ƒ0U·Ÿ_ÙµZĞ¡Ø¯ŸD )À±ó\>¬»ıÊ—üĞ¹ıŠõz N–¤Ä@Öİ~~´Ê-èÇP¬×{rs€¿´@¬<—œ›|.]ºÔ¸|”Îm|gûõëç¬_¿Şyå•WâKD1—bàM½”¢%¡s\“·Ÿ¥rú1Ëõnì\–Æ’„"-É İ`.4æÛ~%3™àI}[0A²$µ“= -Ò>BH"G®Û^r„­<ÂEBGİi Ú%”˜’9Ì@^İ~~
@«ıŠüú1Üì€†@’ tû-[¶ÌèÏ{%@CÙ$ğmAgüøñÎš5kÊ†Ñ…ÈøœŠ/åŒOÿˆlßäÓ¿„áBĞ@.X°À±uäp¥Oüî6œ—x²9MPn¿`ß·o_§¾¾^nÁ`t…
¥§(úª»™ƒ\rûùsÆAÒyóæéÛ‚şT…¡@h
ƒE0lØ0çÎ;ïtÚµÓ˜kÆ¸N ¡¡ÁYµjUà
S#ì|^ã½º- |¢İpÃ
N—.…­ØŞ¥`×^{­zLñ6ƒƒ4 ŸÄ›†bç¨öe—]&"ªd€sÎœ9UŞ¥àU0ğ!
ÀÁ*nPĞ*`—ÿæ›oÖ¨v•¼¹Ái8GåşÔÿhh ØmœŠÍËÀäÉ“sÏ=×{JÇU0ÀÕ‚óçÏwZ·æş’ˆø”ƒ€ì›ö8bEzôèá,Y²Dïş![CŸ>}œ7:k×®
“noÆÀfö >jvR?#b€ƒXˆ(¶üFÃAT¾FÕÕióêˆ[Á{ì°zvÄç>º¡C‡Êía+[0B2Dµœ=€íG~ë(
øÄºñÆÕõ‚LO×\sÜ‚>"8|‹`[)
&Lp8ø'‰–öäŒ”Óí4 oGeÎ#£ÛÀlÙ’_\“DÍ€Ü‚‘2ZØl¢Üi´9Œ
täÈ‘9f Ş¢Ë-¿œ¼‹=€‡YÌyˆn?uQã¯}XÍ¬ÍsAïi >=ŒĞ1æ=RÉí+à +
­Ü‚¡¸.2 šŠKì«·ßôéÓCÆ¢Ûƒ20hĞ ‡Ë«%53À5@…MA¹%˜¦×Ì£ãÈí‚¼·j[õä9Î;¸û _(¯ú§¿µ0ÀÕ~rûÕÂ\¸{ômÁPüÜÿ®x#TT9¾™n?¾Êí—N# á•×¥&î}× ¬¯)
İTVL¯!¸ßÔjÁªë`ïp
 ß8@RrûUAVŒAå¬šÜ=¸ã-Şå€÷pLHª`@n¿*ÈŠ1¨Ü‚U“Ëõ?}w
 ]ìH2@·ß´iÓ†V°¸ [Ë¯%àôÿ‚ëß5 8±)Ğ­
T`€›|rZbZ-¸.Ö!da+@× ğÎçßó€Zígf[0p½¼æ†ô ä¤ I´Égr¸$· o%PÇ_rCy
ÀVœ|ß½ ÿ¥à"mòYšÎÊ-è[ lÚÄk xAã ø“Û¯9]¢[pÒ¤IåÈ¨¬pP“ÇÏk ŠºFeÙÌÈígHEødƒnAm"Z–$õ5}„›‚zå8üéô2røX›|– ÅàSÜ»w¯³råJƒs™JÖ~T›fşz{ ÌÍ« ÷xĞj?jµàQ•Eİnò ğjsÀùÁ|GxĞ·ı<dXt(·àQ•Eİ.¬p¯47 Üğ)÷¢ş;…Ïysµ_«V­D‡…È-XTiÔí¢ı?› †~¼è–œÿÛÏî ·`Qı=Vô?šòú^à
€‚¹ºı–.]ª|XŞ
ômÁB~€¿?ŠÆøJõ ŞD —·äüÜ~Ùh rê‘óÿ©ÛERªÀ…Aİ€óŠBæìİ~wÜq‡Ó¾}ûœ•<›Å•[Ğ¹5ûdóÚ-Õ`˜5 ?Kqİ~l4’ì0@·à)§œ’/I‚®(¼œà‡Ø‹ü…¥nÎê9¹ı²Y³4èœ!˜CÙˆ2×—*w9ÀÀGKİõsî&Ÿrûe³¦súé¶? 6Ù8JÊ |(òuwOä´d°&K)‡nA¾Ê?RšÒn@7,·º8Á=‘õÿrûe½†•nÁM›69k×òM7óÂéı·J•´R€]†e¥nÊê9¹ı²Z³Ååâ /?á“o>ŒÒó•¾¤”rzrÒÀ óó`åöóV{ö»uëæ4448«V­Êra÷ p³ îõQRZ”<{ädK.F9•½#~Tâ¾ûîs.¾øâìN%*Ë 
ÀğáÃuë8G&“²¥ì/W:*x%á{Ã}@¦
 »‚lõõõNc#çAIòÀÀ±Ç›õiŞ÷£Ë*?ëØ¯À0}€g€ãùC"Ä€pÛ¯³€Šßû¨4è–’Ò(bÀ8€_QùY” €áîr7'€—ˆ`·ÿî ùj ¸6à… *Œ©3ÀWögƒä"¨àl¢
¡Âˆ1:ì±Sg}%È  	¹¥P?÷„ş‹1`›£¯ÉYĞ ãâ"‹‚Dª0b@¤Æ İö”Ÿ9¬¦Àğı¾[tá‰F1À‡ôp`kĞ\UÓ`œÜRø·A#W81 e`)RÛZMŠÕö ÷€[uæ‰F0ğ	rq.ÀÕ¥Ú #^ğ=C"Ä€9P'«R~f½– ï
pn€zdC"Òe ¦§?³\K€÷½¨@&$b }jzú3Ûµö x/{èÄ1 Ra€#ÿ|÷çÆŸUK­= &Ä^€æTM¹n‘2À9ÿ5)?s¦Àû{O'ó‡DˆDà’ßo [kMÕoK0¿xÿŒ ÜTd‚_@]b ræ ÆGÃÄ¶À´; «€¯ò‡DˆDàêÜ1ÀgaRÛ`ÚÜ'`0ˆÂ  ‰>\ë/ù„ñ½fĞùƒøñ÷„Å€ˆß!fn÷Z¢|bŸ†ÜğU .t®åà¤ŸÑÀÚrª9Å+€›ı‘­€±î	ıb rnEŒDk”= æé8àÀÙü!b RClã€PŞEÙ`¼ÜŒK†'~ß@‰ Ë}*°!`ø@Á¢6 Lô
 ;À	$b@DÃÀ?#šÈgŞFı
àµV”ˆ1vıÇ;ÃEsôİQ¹›ÇÌ=É®ö4¿ ßb@TÅÀn„ş!¹ò3q¼0^ÊV€ã c ‰µ1ğÜ¶´¶[ıïŠëÀM¹=8Iˆİ‰Õ1@Ú…@Cu··`N¸oÀã WJÄ€Æ WúÑåÇe÷±Iœ¯ n¦¹Nàmà¯€¸ÆÜ´ô_d(Ä4`EÜ…IÂ °¯œ"ÌµË1 *3ğ+\şEå Ñ\MâÀÍ)g	rÁ¦
»Œè¿8š>õ¿pô?vIÒ °0€Ç€~ü!b ˆ­øÅ$'Ó%"I¿“¿RıÀi1 0°‡? S~&Ô Ór…ä’Æ€¤{ nô_˜ÄÀÈÌLà?’ÎT€eäÔÆÀ7ùC"rÎÀOQ~"qIË ° O 8?$b §Ü‹rÿ#@×_â’v¼JÌ™‚£/¹é3ğ'dá/ÈÖ÷W[¤¤›ço'Nü
ğlóú-2Î Ûüå@jÊO~Óî0”À2` HÄ@ÆØ„òĞ+–ª¤İpOB® ŞuOè¿È(lãS€Ô•Ÿü¦9Èô½ò~ğcß:x/èXd„.ğù°Æ”ò˜d ÈÉVày@F $H2Å •Ÿïü+M*•i€Ül8O@F $H2Á •Ÿå®2­4& r´
POÀ´Ö¢üÔÂ€ûä7NùYS
 ó¶ øÀYƒ1`ğã;ÿJS3n² g['‘@W@"la`32Ên?'ûHB2p
îhÄm€mu ‰“×j@F@˜ÜV ²­Z!¦¿xIä”ÉÿH®y™Ñ±)üù>ÀåZ!6 ºà”aÎ`äş‚¦ÌdDV$9f€ëù	pM¿6»I¨!LG:\LdrwPyË~ıPá§%Ôæ•L3Æá7çTKÑÄAm€mo|³6©Ÿ	3Ğé-Òh J3¿¼?67 á¶yr¶”"€ûşàgÈÎ4. $±1À÷ı_¼[*Š¸&¸¤˜S/õdq´Îìãä‰ÁCŞâh Š3¿¼>Š6Å¶%±€¶Èã\€#´RZq¦
ğ=lK|Å”XÆÀXäWSˆe j5 /¡ıĞÓ$±˜:äıv@½‚ †€Î8Ğ×
d„1(‡z2~Fà)´ùö3¢ôÍ‹ÁŞÀl€®C¿† ëùâè#´‰›í=².\Lt? %Ñ N$9b %Ê:àşƒ2ùä€u	 É1|-˜	ldòÁ÷œœt $b À@?ü¥·@† »FàcÔïÏ^€D”d€[9ıà zÙà€ŠÏ:
HÄ@ ¾ŒP2v )~ ¦®@•àüïŸz5°Ç|€úÒ¿R«ÖµªàÁ|`# W39Ø‚ºá<î"-±0Àï\<ìdÒå€uÀoGLz 1œGp°à—e’å€¯d‹ .øj
HÄ@jôFÊ3€•@ c{s<ÿùJ&	É@‹÷ëöb¸ÙÀw‹  ²§ ©nÁµàvğœ²û< ‰ˆ€ˆˆ,M;œû*p>p!0hHüà{=•»ğüxà]IÄÈ DLh™èÚâ<'¡Œh8Ç@V Á#ïã˜Jÿ°àfû IŒÈ ÄHn…¨ûãWŸ}àNÆt[uò$Ÿ¢°›§å ş
@’ 2 	’]&)† #€3ˆ“,	=%¯TôÕÀkÀ&à  I‰€”ˆ÷I¶®Ó³ğ Ù[8	è	´L–]È]tïTğgõÀ6à-@b2 U†OVºã:
 
A?€¯
} .iî|	àxCœÂ÷rvßw; ÎÀ#ê>éi 8_b82 †WP€ìÑõè  {'n¯áÓ8ğz;€Æ¤yİsŸ œÃ@¥¦¼P¡·o|ÂSùih $3ğÿ@ß¹jìŠá    IEND®B`‚



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\globals.css
==================================================
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\layout.tsx
==================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\app\page.tsx
==================================================
import Image from "next/image";

export default function Home() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
      <main className="flex min-h-screen w-full max-w-3xl flex-col items-center justify-between py-32 px-16 bg-white dark:bg-black sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={100}
          height={20}
          priority
        />
        <div className="flex flex-col items-center gap-6 text-center sm:items-start sm:text-left">
          <h1 className="max-w-xs text-3xl font-semibold leading-10 tracking-tight text-black dark:text-zinc-50">
            To get started, edit the page.tsx file.
          </h1>
          <p className="max-w-md text-lg leading-8 text-zinc-600 dark:text-zinc-400">
            Looking for a starting point or more instructions? Head over to{" "}
            <a
              href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              className="font-medium text-zinc-950 dark:text-zinc-50"
            >
              Templates
            </a>{" "}
            or the{" "}
            <a
              href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              className="font-medium text-zinc-950 dark:text-zinc-50"
            >
              Learning
            </a>{" "}
            center.
          </p>
        </div>
        <div className="flex flex-col gap-4 text-base font-medium sm:flex-row">
          <a
            className="flex h-12 w-full items-center justify-center gap-2 rounded-full bg-foreground px-5 text-background transition-colors hover:bg-[#383838] dark:hover:bg-[#ccc] md:w-[158px]"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={16}
              height={16}
            />
            Deploy Now
          </a>
          <a
            className="flex h-12 w-full items-center justify-center rounded-full border border-solid border-black/[.08] px-5 transition-colors hover:border-transparent hover:bg-black/[.04] dark:border-white/[.145] dark:hover:bg-[#1a1a1a] md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Documentation
          </a>
        </div>
      </main>
    </div>
  );
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\domain\enums.ts
==================================================
// src/domain/enums.ts
// Scope-locked enums. Do not modify without updating DB constraints + UI + tests.

export enum Department {
    Staffing = "STAFFING",
    CaseManagement = "CASE_MANAGEMENT",
    Billing = "BILLING",
}

/**
 * Stage values are fixed by scope.
 * Important: stage lists are per-department and must be validated.
 */
export enum StaffingStage {
    OpenPending = "OPEN_PENDING",
    RequestContactInfo = "REQUEST_CONTACT_INFO",
    ContactInfoSent = "CONTACT_INFO_SENT",
    ProviderScheduled = "PROVIDER_SCHEDULED",
    Staffed = "STAFFED",
}

export enum CaseManagementStage {
    FollowingUp = "FOLLOWING_UP",
    Complete = "COMPLETE",
}

export enum BillingStage {
    FollowingUp = "FOLLOWING_UP",
    Complete = "COMPLETE",
}

/**
 * Used everywhere for validation, UI dropdowns, and API constraints.
 * This is the single source of truth for allowed stages.
 */
export const STAGES_BY_DEPARTMENT = {
    [Department.Staffing]: [
        StaffingStage.OpenPending,
        StaffingStage.RequestContactInfo,
        StaffingStage.ContactInfoSent,
        StaffingStage.ProviderScheduled,
        StaffingStage.Staffed,
    ],
    [Department.CaseManagement]: [
        CaseManagementStage.FollowingUp,
        CaseManagementStage.Complete,
    ],
    [Department.Billing]: [BillingStage.FollowingUp, BillingStage.Complete],
} as const;

export type AnyStage =
    | StaffingStage
    | CaseManagementStage
    | BillingStage;

/**
 * Drafts are "draft-first". No auto-send without human approval.
 * Draft types listed below cover scope-required scenarios without adding new business rules.
 */
export enum DraftType {
    ExternalReply = "EXTERNAL_REPLY", // general reply to sender/requestor
    StaffingRequestContactInfo = "STAFFING_REQUEST_CONTACT_INFO",
    StaffingStaffedConfirmation = "STAFFING_STAFFED_CONFIRMATION",
    CaseManagementFollowUp = "CASE_MANAGEMENT_FOLLOW_UP",
    BillingFollowUp = "BILLING_FOLLOW_UP",
    AuthorizationFollowUp = "AUTHORIZATION_FOLLOW_UP",
    EscalationInternal = "ESCALATION_INTERNAL", // internal only to dept inboxes
}

export enum DraftStatus {
    Created = "CREATED",
    Edited = "EDITED",
    Approved = "APPROVED",
    Sent = "SENT",
    Discarded = "DISCARDED",
}

/**
 * SLA is fixed by scope (hours).
 */
export const SLA_HOURS_BY_DEPARTMENT: Record<Department, number> = {
    [Department.Staffing]: 2,
    [Department.CaseManagement]: 1,
    [Department.Billing]: 4,
};

/**
 * Escalation email subject prefix is fixed by scope.
 */
export const ESCALATION_SUBJECT_PREFIX = "ESCALATION:";

/**
 * Helper: validate stage belongs to department (use in API + services).
 */
export function isValidStageForDepartment(
    department: Department,
    stage: string
): stage is AnyStage {
    return (STAGES_BY_DEPARTMENT[department] as readonly string[]).includes(stage);
}

/**
 * Helper: get stages for UI dropdowns.
 */
export function getStagesForDepartment(department: Department): readonly AnyStage[] {
    return STAGES_BY_DEPARTMENT[department] as readonly AnyStage[];
}

// src/domain/enums.ts

export type StageForDepartment<D extends Department> =
    D extends Department.Staffing ? StaffingStage :
        D extends Department.CaseManagement ? CaseManagementStage :
            D extends Department.Billing ? BillingStage :
                never;

export type StagesByDepartment = typeof STAGES_BY_DEPARTMENT;

export function assertNever(x: never): never {
    throw new Error(`Unexpected value: ${String(x)}`);
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\domain\rules.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\domain\validators.ts
==================================================
import {
    AnyStage,
    Department,
    DraftStatus,
    DraftType,
    isValidStageForDepartment,
} from "./enums";

export function assertDepartment(dept: string): asserts dept is Department {
    if (!Object.values(Department).includes(dept as Department)) {
        throw new Error(`Invalid department: ${dept}`);
    }
}

export function assertStage(dept: Department, stage: string): asserts stage is AnyStage {
    if (!isValidStageForDepartment(dept, stage)) {
        throw new Error(`Invalid stage "${stage}" for department "${dept}"`);
    }
}

export function assertDraftType(t: string): asserts t is DraftType {
    if (!Object.values(DraftType).includes(t as DraftType)) {
        throw new Error(`Invalid draftType: ${t}`);
    }
}

export function assertDraftStatus(s: string): asserts s is DraftStatus {
    if (!Object.values(DraftStatus).includes(s as DraftStatus)) {
        throw new Error(`Invalid draft status: ${s}`);
    }
}

const allowedTransitions: Record<DraftStatus, DraftStatus[]> = {
    [DraftStatus.Created]: [DraftStatus.Edited, DraftStatus.Discarded, DraftStatus.Approved],
    [DraftStatus.Edited]: [DraftStatus.Edited, DraftStatus.Discarded, DraftStatus.Approved],
    [DraftStatus.Approved]: [DraftStatus.Sent, DraftStatus.Discarded],
    [DraftStatus.Sent]: [],
    [DraftStatus.Discarded]: [],
};

export function assertDraftStatusTransition(from: DraftStatus, to: DraftStatus) {
    if (!allowedTransitions[from].includes(to)) {
        throw new Error(`Invalid draft status transition: ${from} -> ${to}`);
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\lib\actor.ts
==================================================
import { NextRequest } from "next/server";

export function getActorUserId(req: NextRequest): string | null {
    const v = req.headers.get("x-actor-user-id");
    return v?.trim() ? v.trim() : null;
}

export function requireActorUserId(req: NextRequest): string {
    const id = getActorUserId(req);
    if (!id) throw new Error("Missing x-actor-user-id header");
    return id;
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\lib\db.ts
==================================================
import "dotenv/config";
import { PrismaClient } from "@prisma/client";
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
    globalForPrisma.prisma ??
    new PrismaClient({
        adapter: new PrismaMariaDb(process.env.DATABASE_URL!),
    });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\lib\graph.ts
==================================================
import "dotenv/config";
import { Client } from "@microsoft/microsoft-graph-client";
import { ClientSecretCredential } from "@azure/identity";

function required(name: string) {
    const v = process.env[name];
    if (!v) throw new Error(`Missing env: ${name}`);
    return v;
}

export type GraphRecipient = {
    emailAddress: { address: string; name?: string };
};

export type GraphBody = {
    contentType: "HTML" | "Text";
    content: string;
};

export type GraphMessage = {
    id: string;
    subject?: string;
    conversationId?: string;
    receivedDateTime?: string;
    sentDateTime?: string;
    from?: unknown;
    toRecipients?: unknown[];
    ccRecipients?: unknown[];
    body?: { contentType?: string; content?: string };
    bodyPreview?: string;
    hasAttachments?: boolean;
    internetMessageId?: string;
};

export type GraphListResponse<T> = {
    value: T[];
    "@odata.nextLink"?: string;
    "@odata.deltaLink"?: string;
};

export type GraphAttachmentListItem = {
    id: string;
    name: string;
    contentType?: string;
    size?: number;
};

export type GraphAttachment = {
    id: string;
    name: string;
    contentType: string;
    contentBytes?: string;
};

const tenantId = required("GRAPH_TENANT_ID");
const clientId = required("GRAPH_CLIENT_ID");
const clientSecret = required("GRAPH_CLIENT_SECRET");

const credential = new ClientSecretCredential(tenantId, clientId, clientSecret);

async function getAccessToken(): Promise<string> {
    const scope = "https://graph.microsoft.com/.default";
    const token = await credential.getToken(scope);
    if (!token?.token) throw new Error("Failed to acquire Graph access token");
    return token.token;
}

export async function graphClient() {
    const token = await getAccessToken();
    return Client.init({
        authProvider: (done) => done(null, token),
    });
}

function toRecipients(addresses: unknown): GraphRecipient[] | undefined {
    if (!Array.isArray(addresses)) return undefined;

    const out: GraphRecipient[] = [];
    for (const v of addresses) {
        if (typeof v !== "string") continue;
        const a = v.trim();
        if (!a) continue;
        out.push({ emailAddress: { address: a } });
    }
    return out.length ? out : undefined;
}

export async function listInboxMessages(sharedInboxUpn: string, top = 5): Promise<GraphListResponse<GraphMessage>> {
    const g = await graphClient();
    return g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/mailFolders/Inbox/messages`)
        .top(top)
        .select("id,subject,conversationId,receivedDateTime,from,hasAttachments,bodyPreview")
        .orderby("receivedDateTime desc")
        .get();
}

export async function getMessage(sharedInboxUpn: string, messageId: string): Promise<GraphMessage> {
    const g = await graphClient();
    return g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${messageId}`)
        .select(
            "id,subject,conversationId,receivedDateTime,sentDateTime,from,toRecipients,ccRecipients,body,bodyPreview,hasAttachments,internetMessageId"
        )
        .get();
}

export async function listConversationMessages(
    sharedInboxUpn: string,
    conversationId: string,
    top = 50
): Promise<GraphListResponse<GraphMessage>> {
    const g = await graphClient();
    return g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages`)
        .filter(`conversationId eq '${conversationId}'`)
        .top(top)
        .select("id,subject,conversationId,receivedDateTime,from,toRecipients,ccRecipients,bodyPreview,hasAttachments")
        .orderby("receivedDateTime asc")
        .get();
}

export async function createReplyDraft(
    sharedInboxUpn: string,
    messageId: string,
    commentHtml: string
): Promise<GraphMessage> {
    const g = await graphClient();
    const draft = (await g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${messageId}/createReply`)
        .post({})) as GraphMessage;

    const draftId = draft?.id;
    if (!draftId) return draft;

    await g.api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${draftId}`).patch({
        body: { contentType: "HTML", content: commentHtml },
    });

    return { ...draft, id: draftId };
}

/**
 * Fallback: create a NEW draft message (not a reply) if createReplyDraft fails
 * (meeting request / eventMessage / etc.).
 */
export async function createNewMessageDraft(sharedInboxUpn: string, args: {
    subject: string;
    bodyHtml: string;
    to: string[];
    cc?: string[];
}): Promise<GraphMessage> {
    const g = await graphClient();

    const to = toRecipients(args.to) ?? [];
    const cc = toRecipients(args.cc ?? []) ?? [];

    const draft = (await g.api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages`).post({
        subject: args.subject,
        body: { contentType: "HTML", content: args.bodyHtml },
        toRecipients: to,
        ...(cc.length ? { ccRecipients: cc } : {}),
    })) as GraphMessage;

    return draft;
}

export async function deltaInboxMessages(
    sharedInboxUpn: string,
    deltaLink?: string | null
): Promise<GraphListResponse<GraphMessage>> {
    const g = await graphClient();

    const url = deltaLink
        ? deltaLink
        : `/users/${encodeURIComponent(sharedInboxUpn)}/mailFolders/Inbox/messages/delta?$select=id,subject,conversationId,receivedDateTime,from,hasAttachments,bodyPreview,internetMessageId`;

    return g.api(url).get();
}

export async function listMessageAttachments(
    sharedInboxUpn: string,
    messageId: string
): Promise<GraphListResponse<GraphAttachmentListItem>> {
    const g = await graphClient();
    return g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${messageId}/attachments`)
        .select("id,name,contentType,size")
        .get();
}

export async function patchDraft(
    sharedInboxUpn: string,
    draftMessageId: string,
    patch: {
        subject?: string;
        bodyHtml?: string;
        to?: string[];
        cc?: string[];
    }
) {
    const g = await graphClient();

    const to = patch.to ? toRecipients(patch.to) : undefined;
    const cc = patch.cc ? toRecipients(patch.cc) : undefined;

    return g.api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${draftMessageId}`).patch({
        ...(patch.subject ? { subject: patch.subject } : {}),
        ...(patch.bodyHtml ? { body: { contentType: "HTML", content: patch.bodyHtml } } : {}),
        ...(to ? { toRecipients: to } : {}),
        ...(cc ? { ccRecipients: cc } : {}),
    });
}

export async function downloadAttachmentContent(
    sharedInboxUpn: string,
    messageId: string,
    attachmentId: string
): Promise<{ name: string; contentType: string; bytes: Buffer }> {
    const g = await graphClient();

    const att = (await g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${messageId}/attachments/${attachmentId}`)
        .get()) as GraphAttachment;

    const contentBytes = att?.contentBytes;
    if (!contentBytes) {
        throw new Error("Attachment has no contentBytes (not a fileAttachment?)");
    }

    return {
        name: att.name,
        contentType: att.contentType,
        bytes: Buffer.from(contentBytes, "base64"),
    };
}

export async function fetchDeltaAll(
    sharedInboxUpn: string,
    deltaLink?: string | null
): Promise<{ items: GraphMessage[]; deltaLink: string | null }> {
    const items: GraphMessage[] = [];
    let page = await deltaInboxMessages(sharedInboxUpn, deltaLink ?? null);

    while (true) {
        items.push(...(page.value ?? []));
        const next = page["@odata.nextLink"];
        if (next) {
            page = await deltaInboxMessages(sharedInboxUpn, next);
            continue;
        }
        const finalDelta = page["@odata.deltaLink"] ?? null;
        return { items, deltaLink: finalDelta };
    }
}

export async function deltaInboxMessagesFrom(
    sharedInboxUpn: string,
    fromIso: string
): Promise<GraphListResponse<GraphMessage>> {
    const g = await graphClient();

    // Limit initial sync window only (when no delta cursor yet)
    const url =
        `/users/${encodeURIComponent(sharedInboxUpn)}/mailFolders/Inbox/messages/delta` +
        `?$select=id,subject,conversationId,receivedDateTime,from,hasAttachments,bodyPreview,internetMessageId` +
        `&$filter=receivedDateTime ge ${fromIso}`;

    return g.api(url).get();
}

export async function fetchDeltaAllFrom(
    sharedInboxUpn: string,
    fromIso: string
): Promise<{ items: GraphMessage[]; deltaLink: string | null }> {
    const items: GraphMessage[] = [];
    let page = await deltaInboxMessagesFrom(sharedInboxUpn, fromIso);

    while (true) {
        items.push(...(page.value ?? []));
        const next = page["@odata.nextLink"];
        if (next) {
            page = await deltaInboxMessages(sharedInboxUpn, next);
            continue;
        }
        const finalDelta = page["@odata.deltaLink"] ?? null;
        return { items, deltaLink: finalDelta };
    }
}

export async function sendDraft(sharedInboxUpn: string, draftMessageId: string): Promise<void> {
    const g = await graphClient();
    await g
        .api(`/users/${encodeURIComponent(sharedInboxUpn)}/messages/${draftMessageId}/send`)
        .post({});
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\lib\logger.ts
==================================================
import pino from "pino";
import type { Bindings } from "pino";

export const logger = pino({
    level: process.env.LOG_LEVEL ?? "info",
    transport:
        process.env.APP_ENV === "development"
            ? { target: "pino-pretty", options: { colorize: true } }
            : undefined,
});

export function withCtx(ctx: Bindings) {
    return logger.child(ctx);
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\lib\openai.ts
==================================================
import OpenAI from "openai";

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

/**
 * Step 5 design:
 * - PDFs: upload -> input_file
 * - Images (jpg/png/webp): send as input_image (data URL), DO NOT upload
 * - docx/xlsx/csv: extract to text locally and include as input_text
 */
const MODEL_INLINE = process.env.OPENAI_MODEL_INLINE ?? "gpt-5.2";
const MODEL_DRAFT = process.env.OPENAI_MODEL_DRAFT ?? "gpt-5.2";

export type UploadFile = {
    name: string;
    bytes: Buffer;
    contentType?: string;
};

export type InlineImage = {
    name: string;
    contentType: string; // e.g. image/png
    dataUrl: string; // data:<mime>;base64,<...>
};

export type InlineTextAttachment = {
    name: string;
    contentType?: string;
    text: string;
};

type ResponsesLike = {
    output_text?: string;
};

function bufferToDataUrl(buf: Buffer, contentType: string): string {
    const b64 = buf.toString("base64");
    return `data:${contentType};base64,${b64}`;
}

/**
 * OpenAI Files API upload:
 * IMPORTANT: only use for formats the Files+Responses "input_file" accepts reliably.
 * In our pipeline we only upload PDFs.
 */
async function uploadUserDataFile(file: UploadFile): Promise<string> {
    const contentType = file.contentType ?? "application/octet-stream";

    // Buffer -> Uint8Array (valid BlobPart)
    const bytes = new Uint8Array(file.bytes);

    const created = await client.files.create({
        file: new File([bytes], file.name, { type: contentType }),
        purpose: "user_data",
    });

    return created.id;
}

type ResponseInputTextPart = { type: "input_text"; text: string };
type ResponseInputFilePart = { type: "input_file"; file_id: string };

// FIX: include `detail`
type ResponseInputImagePart = {
    type: "input_image";
    image_url: string;                // data URL is OK
    detail: "auto" | "low" | "high";  // REQUIRED by SDK types
};

type ResponseUserContentPart =
    | ResponseInputTextPart
    | ResponseInputFilePart
    | ResponseInputImagePart;


async function responsesJson<T>(args: {
    model?: string;
    system: string;
    userText: string;
    pdfFileIds: string[];
    images: InlineImage[];
    attachmentTexts: InlineTextAttachment[];
}): Promise<T> {
    const pdfParts: ResponseInputFilePart[] = args.pdfFileIds.map((id) => ({
        type: "input_file",
        file_id: id,
    }));

    const imageParts: ResponseInputImagePart[] = args.images.map((img) => ({
        type: "input_image",
        image_url: img.dataUrl,
        detail: "auto",
    }));

    const textParts: ResponseInputTextPart[] = args.attachmentTexts.map((t) => ({
        type: "input_text",
        text:
            `\n\n[ATTACHMENT_TEXT_BEGIN]\n` +
            `name: ${t.name}\n` +
            `contentType: ${t.contentType ?? "unknown"}\n` +
            `text:\n${t.text}\n` +
            `[ATTACHMENT_TEXT_END]\n`,
    }));

    const userContent: ResponseUserContentPart[] = [
        { type: "input_text", text: args.userText },
        ...textParts,
        ...pdfParts,
        ...imageParts,
    ];

    const resp = await client.responses.create({
        model: args.model ?? MODEL_INLINE,
        tools: [{ type: "code_interpreter", container: { type: "auto" } }],
        input: [
            {
                role: "system",
                content: [{ type: "input_text", text: args.system }],
            },
            {
                role: "user",
                content: userContent,
            },
        ],
    });

    const out = (resp as unknown as ResponsesLike).output_text;
    if (!out) throw new Error("OpenAI Responses API returned empty output_text");
    return JSON.parse(out) as T;
}

async function chatJson<T>(args: { model: string; system: string; user: string }): Promise<T> {
    const res = await client.chat.completions.create({
        model: args.model,
        temperature: 0,
        messages: [
            { role: "system", content: args.system },
            { role: "user", content: args.user },
        ],
        response_format: { type: "json_object" },
    });

    const content = res.choices?.[0]?.message?.content;
    if (!content) throw new Error("OpenAI returned empty content");
    return JSON.parse(content) as T;
}

export const openai = {
    /**
     * Step 5: Inline extraction + classification in ONE call.
     *
     * - PDFs uploaded -> input_file
     * - Images passed as input_image (data URLs)
     * - docx/xlsx/csv passed as extracted text blocks
     */
    async classifyInline<T>(p: {
        system: string;
        user: string;
        pdfFiles: UploadFile[];
        images: InlineImage[];
        attachmentTexts: InlineTextAttachment[];
    }): Promise<T> {
        const pdfFileIds: string[] = [];
        for (const f of p.pdfFiles) {
            const id = await uploadUserDataFile(f);
            pdfFileIds.push(id);
        }

        return responsesJson<T>({
            system: p.system,
            userText: p.user,
            pdfFileIds,
            images: p.images,
            attachmentTexts: p.attachmentTexts,
        });
    },

    /**
     * Draft generation uses already-saved extractedJson, so no file inputs needed.
     */
    draft<T>(p: { system: string; user: string }): Promise<T> {
        return chatJson<T>({
            model: MODEL_DRAFT,
            system: p.system,
            user: p.user,
        });
    },

    // exported for reuse if needed
    bufferToDataUrl,
};



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\attachment.repo.ts
==================================================
import { prisma } from "@/lib/db";

export async function upsertAttachment(params: {
    messageId: string;
    graphAttachmentId: string;
    filename: string;
    mimeType?: string | null;
    sizeBytes?: number | null;
}) {
    return prisma.attachment.upsert({
        where: {
            messageId_graphAttachmentId: {
                messageId: params.messageId,
                graphAttachmentId: params.graphAttachmentId,
            },
        },
        update: {
            filename: params.filename,
            mimeType: params.mimeType ?? null,
            sizeBytes: params.sizeBytes ?? null,
        },
        create: {
            messageId: params.messageId,
            graphAttachmentId: params.graphAttachmentId,
            filename: params.filename,
            mimeType: params.mimeType ?? null,
            sizeBytes: params.sizeBytes ?? null,
            status: "PENDING",
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\audit.repo.ts
==================================================
import { prisma } from "@/lib/db";
import { AuditAction, Prisma } from "@prisma/client";

type AuditCtx = {
    threadId?: string;
    messageId?: string;
    draftId?: string;
    actorUserId?: string;
    payload?: Prisma.InputJsonValue;
};

export async function audit(action: AuditAction, ctx: AuditCtx) {
    return prisma.auditLog.create({
        data: {
            action,
            threadId: ctx.threadId,
            messageId: ctx.messageId,
            draftId: ctx.draftId,
            actorUserId: ctx.actorUserId,
            payload: ctx.payload ?? Prisma.JsonNull,
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\draft.repo.ts
==================================================
import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";

export type CreateDraftParams = {
    threadId: string;
    draftType: string;
    status: string;
    subject: string | null;
    bodyHtml: string | null;
    bodyText: string | null;
    toJson: unknown; // string[] in practice
    ccJson: unknown | null; // string[] in practice
    createdByUserId: string | null;
};

export async function createDraft(p: CreateDraftParams) {
    return prisma.draft.create({
        data: {
            threadId: p.threadId,
            draftType: p.draftType,
            status: p.status,
            subject: p.subject,
            bodyHtml: p.bodyHtml,
            bodyText: p.bodyText,
            toJson: p.toJson as never,
            ccJson: (p.ccJson ?? null) as never,
            createdByUserId: p.createdByUserId ?? null,
        },
    });
}

export async function findLatestDraftForThread(threadId: string) {
    return prisma.draft.findFirst({
        where: { threadId },
        orderBy: { createdAt: "desc" },
    });
}

/**
 * Idempotent graph draft linking:
 * - If this draft already has the same graphDraftMessageId -> ok
 * - If the graphDraftMessageId is already used by another Draft -> return null (caller decides what to do)
 */
export async function linkGraphDraftId(draftId: string, graphDraftMessageId: string) {
    // If already linked correctly, do nothing
    const existing = await prisma.draft.findUnique({ where: { id: draftId } });
    if (!existing) return null;

    if (existing.graphDraftMessageId === graphDraftMessageId) return existing;

    // If graphDraftMessageId is already linked to some other row, do NOT violate uniqueness
    const taken = await prisma.draft.findFirst({
        where: { graphDraftMessageId },
        select: { id: true },
    });
    if (taken && taken.id !== draftId) return null;

    try {
        return await prisma.draft.update({
            where: { id: draftId },
            data: { graphDraftMessageId },
        });
    } catch (e: unknown) {
        // In case of race (two workers), handle Prisma unique error safely
        if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === "P2002") {
            return null;
        }
        throw e;
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\escalation.repo.ts
==================================================
import { prisma } from "@/lib/db";

export async function createEscalation(params: {
    threadId: string;
    department: string;
    reason: string;
    draftId?: string | null;
}) {
    return prisma.escalation.create({
        data: {
            threadId: params.threadId,
            department: params.department,
            reason: params.reason,
            draftId: params.draftId ?? null,
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\inbox.repo.ts
==================================================
import { prisma } from "@/lib/db";

export async function getAllSharedInboxes() {
    return prisma.inbox.findMany({ where: { isEscalation: false } });
}

export async function getInboxCursor(inboxId: string) {
    return prisma.inboxCursor.findUnique({ where: { inboxId } });
}

export async function upsertInboxCursor(inboxId: string, deltaLink: string | null) {
    return prisma.inboxCursor.upsert({
        where: { inboxId },
        update: { deltaLink, lastSyncAt: new Date() },
        create: { inboxId, deltaLink, lastSyncAt: new Date() },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\message.repo.ts
==================================================
import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";

export async function upsertMessage(params: {
    threadId: string;
    graphMessageId: string;
    internetMessageId?: string | null;

    fromJson: Prisma.InputJsonValue | typeof Prisma.JsonNull;
    toJson: Prisma.InputJsonValue;
    ccJson?: Prisma.InputJsonValue | typeof Prisma.JsonNull | null;

    subject?: string | null;
    bodyPreview?: string | null;
    bodyHtml?: string | null;
    bodyText?: string | null;

    receivedAt?: Date | null;
    sentAt?: Date | null;

    hasAttachments: boolean;
}) {
    const ccJsonUpdate =
        params.ccJson === undefined ? undefined : params.ccJson ?? Prisma.JsonNull;

    return prisma.emailMessage.upsert({
        where: { graphMessageId: params.graphMessageId },
        update: {
            threadId: params.threadId,
            internetMessageId: params.internetMessageId ?? undefined,

            fromJson: params.fromJson,
            toJson: params.toJson,
            ccJson: ccJsonUpdate,

            subject: params.subject ?? null,
            bodyPreview: params.bodyPreview ?? null,
            bodyHtml: params.bodyHtml ?? null,
            bodyText: params.bodyText ?? null,
            receivedAt: params.receivedAt ?? null,
            sentAt: params.sentAt ?? null,
            hasAttachments: params.hasAttachments,
        },
        create: {
            threadId: params.threadId,
            graphMessageId: params.graphMessageId,
            internetMessageId: params.internetMessageId ?? null,

            fromJson: params.fromJson,
            toJson: params.toJson,
            ccJson: params.ccJson ?? Prisma.JsonNull,

            subject: params.subject ?? null,
            bodyPreview: params.bodyPreview ?? null,
            bodyHtml: params.bodyHtml ?? null,
            bodyText: params.bodyText ?? null,
            receivedAt: params.receivedAt ?? null,
            sentAt: params.sentAt ?? null,
            hasAttachments: params.hasAttachments,
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\repositories\thread.repo.ts
==================================================
import { prisma } from "@/lib/db";
import { Department, StaffingStage } from "@/domain/enums";

export async function upsertThread(params: {
    inboxId: string;
    graphConversationId: string;
    subject?: string | null;
    lastMessageAt?: Date | null;
}) {
    const defaultDepartment = Department.Staffing;
    const defaultStage = StaffingStage.OpenPending;

    return prisma.thread.upsert({
        where: {
            inboxId_graphConversationId: {
                inboxId: params.inboxId,
                graphConversationId: params.graphConversationId,
            },
        },
        update: {
            subject: params.subject ?? undefined,
            lastMessageAt: params.lastMessageAt ?? undefined,
        },
        create: {
            inboxId: params.inboxId,
            graphConversationId: params.graphConversationId,
            subject: params.subject ?? null,
            lastMessageAt: params.lastMessageAt ?? null,
            department: defaultDepartment,
            stage: defaultStage,
            needsReview: false,
            processingStatus: "NEW",
        },
    });
}

export async function getThreadForClassification(threadId: string) {
    return prisma.thread.findUnique({
        where: { id: threadId },
        include: {
            inbox: true,
            messages: {
                orderBy: { receivedAt: "asc" },
                take: 5,
                include: { attachments: true },
            },
        },
    });
}

export async function markThreadClassified(params: {
    threadId: string;
    department: string;
    stage: string;
    needsReview: boolean;
}) {
    return prisma.thread.update({
        where: { id: params.threadId },
        data: {
            department: params.department,
            stage: params.stage,
            needsReview: params.needsReview,
            processingStatus: "CLASSIFIED",
        },
    });
}

export async function getThreadWithLatestMessage(threadId: string) {
    return prisma.thread.findUnique({
        where: { id: threadId },
        include: {
            inbox: true,
            messages: { orderBy: { receivedAt: "desc" }, take: 1 },
        },
    });
}

export async function markThreadDrafted(params: {
    threadId: string;
    draftTypeSuggested?: string | null;
    responseRequired?: boolean | null;
}) {
    return prisma.thread.update({
        where: { id: params.threadId },
        data: {
            processingStatus: "DRAFTED",
            draftTypeSuggested: params.draftTypeSuggested ?? undefined,
            responseRequired: params.responseRequired ?? undefined,
        },
    });
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\classification.service.ts
==================================================
import crypto from "node:crypto";
import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";
import { audit } from "@/repositories/audit.repo";
import { openai, type UploadFile, type InlineImage, type InlineTextAttachment } from "@/lib/openai";
import { AuditAction } from "@prisma/client";
import { assertDepartment, assertStage } from "@/domain/validators";
import { Department } from "@/domain/enums";
import { downloadAttachmentContent } from "@/lib/graph";
import { getThreadForClassification, markThreadClassified } from "@/repositories/thread.repo";

type JsonValue =
    | string
    | number
    | boolean
    | null
    | { [k: string]: JsonValue }
    | JsonValue[];

type AttachmentForClassification = {
    id: string; // DB attachment id
    graphAttachmentId: string;
    filename: string;
    mimeType: string | null;
    status: "PENDING" | "EXTRACTED" | "FAILED";
    contentHash: string | null;
};

type MessageForClassification = {
    id: string; // DB message id
    graphMessageId: string;
    fromJson: unknown;
    subject: string | null;
    bodyPreview: string | null;
    bodyHtml: string | null;
    bodyText: string | null;
    hasAttachments: boolean;
    attachments: AttachmentForClassification[];
};

type ThreadForClassification = {
    id: string;
    processingStatus: "NEW" | "CLASSIFIED" | "DRAFTED" | "DONE" | "FAILED";
    subject: string | null;
    inbox: { emailAddress: string };
    messages: MessageForClassification[];
};

type AttachmentExtractOut = {
    messageGraphId: string;
    graphAttachmentId: string;
    filename: string;
    contentType: string | null;
    extracted: JsonValue | null;
};

type ClassificationInlineResult = {
    department: Department;
    stage: string;
    confidence: number;
    responseRequired?: boolean;
    draftTypeSuggested?: string | null;
    attachments?: AttachmentExtractOut[];
};

function sha256(buf: Buffer): string {
    return crypto.createHash("sha256").update(buf).digest("hex");
}

function isThreadForClassification(x: unknown): x is ThreadForClassification {
    if (!x || typeof x !== "object") return false;
    const o = x as Record<string, unknown>;
    const inbox = o.inbox as Record<string, unknown> | null;
    const messages = o.messages as unknown;

    return (
        typeof o.id === "string" &&
        typeof o.processingStatus === "string" &&
        !!inbox &&
        typeof inbox.emailAddress === "string" &&
        Array.isArray(messages)
    );
}

function extLower(name: string): string {
    const i = name.lastIndexOf(".");
    if (i < 0) return "";
    return name.slice(i + 1).toLowerCase();
}

function isPdf(filename: string, mimeType: string | null): boolean {
    if ((mimeType ?? "").toLowerCase() === "application/pdf") return true;
    return extLower(filename) === "pdf";
}

function isImage(filename: string, mimeType: string | null): boolean {
    const mt = (mimeType ?? "").toLowerCase();
    if (mt.startsWith("image/")) return true;
    const ext = extLower(filename);
    return ext === "jpg" || ext === "jpeg" || ext === "png" || ext === "webp";
}

function isCsv(filename: string, mimeType: string | null): boolean {
    const mt = (mimeType ?? "").toLowerCase();
    if (mt.includes("text/csv")) return true;
    return extLower(filename) === "csv";
}

function isDocx(filename: string, mimeType: string | null): boolean {
    const mt = (mimeType ?? "").toLowerCase();
    if (mt.includes("application/vnd.openxmlformats-officedocument.wordprocessingml.document")) return true;
    return extLower(filename) === "docx";
}

function isXlsx(filename: string, mimeType: string | null): boolean {
    const mt = (mimeType ?? "").toLowerCase();
    if (mt.includes("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")) return true;
    const ext = extLower(filename);
    return ext === "xlsx" || ext === "xls";
}

async function extractDocxText(buf: Buffer): Promise<string> {
    // npm i mammoth
    const mammoth = await import("mammoth");
    const res = await mammoth.extractRawText({ buffer: buf });
    return (res.value ?? "").trim();
}

async function extractXlsxText(buf: Buffer): Promise<string> {
    // npm i xlsx
    const xlsx = await import("xlsx");
    const wb = xlsx.read(buf, { type: "buffer" });
    const sheetNames = wb.SheetNames ?? [];
    if (sheetNames.length === 0) return "";
    const first = wb.Sheets[sheetNames[0]];
    const csv = xlsx.utils.sheet_to_csv(first);
    return csv.trim();
}

export async function classifyThread(threadId: string) {
    const raw = await getThreadForClassification(threadId);
    if (!isThreadForClassification(raw)) return;

    const thread = raw;
    if (thread.processingStatus !== "NEW") return;

    const inboxUpn = thread.inbox.emailAddress;

    // Build message context
    const messagesCtx = thread.messages.map((m) => ({
        graphMessageId: m.graphMessageId,
        from: m.fromJson,
        subject: m.subject,
        preview: m.bodyPreview,
        bodyHtml: m.bodyHtml,
        bodyText: m.bodyText,
        hasAttachments: m.hasAttachments,
    }));

    // Files and mappings
    const pdfFiles: UploadFile[] = [];
    const images: InlineImage[] = [];
    const attachmentTexts: InlineTextAttachment[] = [];

    const attachmentMap: Array<{
        messageGraphId: string;
        attachmentDbId: string;
        graphAttachmentId: string;
        filename: string;
        mimeType: string | null;
        contentHash: string;
    }> = [];

    for (const m of thread.messages) {
        for (const a of m.attachments) {
            // If already extracted with a hash, skip download completely
            if (a.status === "EXTRACTED" && a.contentHash) continue;

            let content: { name: string; contentType: string; bytes: Buffer };
            try {
                // Download bytes from Graph (may fail: non-fileAttachment, deleted, 403, etc.)
                content = await downloadAttachmentContent(inboxUpn, m.graphMessageId, a.graphAttachmentId);
            } catch (e: unknown) {
                const msg = e instanceof Error ? e.message : String(e);
                await prisma.attachment.update({
                    where: { id: a.id },
                    data: { status: "FAILED", lastError: msg },
                });
                continue;
            }

            const hash = sha256(content.bytes);

            // Store/refresh hash
            await prisma.attachment.update({
                where: { id: a.id },
                data: { contentHash: hash },
            });

            // If already extracted and same hash, skip
            if (a.status === "EXTRACTED" && a.contentHash === hash) continue;

            const contentType = a.mimeType ?? content.contentType ?? "application/octet-stream";

            try {
                // Decide pathway
                if (isPdf(a.filename, a.mimeType)) {
                    pdfFiles.push({
                        name: a.filename,
                        bytes: content.bytes,
                        contentType,
                    });
                } else if (isImage(a.filename, a.mimeType)) {
                    const imgContentType = contentType.startsWith("image/") ? contentType : "image/png";
                    images.push({
                        name: a.filename,
                        contentType: imgContentType,
                        dataUrl: openai.bufferToDataUrl(content.bytes, imgContentType),
                    });
                } else if (isCsv(a.filename, a.mimeType)) {
                    attachmentTexts.push({
                        name: a.filename,
                        contentType,
                        text: content.bytes.toString("utf8").slice(0, 200_000), // guard
                    });
                } else if (isDocx(a.filename, a.mimeType)) {
                    const text = await extractDocxText(content.bytes);
                    attachmentTexts.push({
                        name: a.filename,
                        contentType,
                        text: text.slice(0, 200_000),
                    });
                } else if (isXlsx(a.filename, a.mimeType)) {
                    const text = await extractXlsxText(content.bytes);
                    attachmentTexts.push({
                        name: a.filename,
                        contentType,
                        text: text.slice(0, 200_000),
                    });
                } else {
                    // unsupported: mark failed (so thread can still proceed)
                    await prisma.attachment.update({
                        where: { id: a.id },
                        data: {
                            status: "FAILED",
                            lastError: `UNSUPPORTED_ATTACHMENT_TYPE filename=${a.filename} mimeType=${a.mimeType ?? "null"}`,
                        },
                    });
                    continue;
                }
            } catch (e: unknown) {
                // Any extraction/parser failure should not block the thread
                const msg = e instanceof Error ? e.message : String(e);
                await prisma.attachment.update({
                    where: { id: a.id },
                    data: { status: "FAILED", lastError: msg },
                });
                continue;
            }

            attachmentMap.push({
                messageGraphId: m.graphMessageId,
                attachmentDbId: a.id,
                graphAttachmentId: a.graphAttachmentId,
                filename: a.filename,
                mimeType: a.mimeType,
                contentHash: hash,
            });
        }
    }

    const system = `
You classify healthcare operations email threads AND extract useful data from attachments.

Return STRICT JSON only.

Choose One Single Department:
- STAFFING
- CASE_MANAGEMENT
- BILLING

Choose a VALID STAGE BY DEPARTMENT (you MUST follow this):
- If Department = STAFFING, stage MUST be one of:
  OPEN_PENDING, REQUEST_CONTACT_INFO, CONTACT_INFO_SENT, PROVIDER_SCHEDULED, STAFFED
- If Department = CASE_MANAGEMENT, stage MUST be one of:
  FOLLOWING_UP, COMPLETE
- If Department = BILLING, stage MUST be one of:
  FOLLOWING_UP, COMPLETE
  
Attachments inputs you may receive:
- PDFs as files
- Images as images
- DOCX/XLSX/CSV provided as extracted text blocks in the prompt

Use attachment content heavily if email body is sparse.

Output JSON schema:
{
  "department": "STAFFING|CASE_MANAGEMENT|BILLING",
  "stage": "<VALID_STAGE_FOR_DEPARTMENT>",
  "confidence": 0.0-1.0,
  "responseRequired": true|false,
  "draftTypeSuggested": "<string|null>",
  "attachments": [
    {
      "messageGraphId": "<string>",
      "graphAttachmentId": "<string>",
      "filename": "<string>",
      "contentType": "<string|null>",
      "extracted": {
        "docType": "<string|null>",
        "summaryText": "<string|null>",
        "patient": { "name": "<string|null>", "dob": "<string|null>", "address": "<string|null>" },
        "insurance": { "payer": "<string|null>", "memberId": "<string|null>" },
        "dates": { "evaluationDate": "<string|null>", "dosFrom": "<string|null>", "dosTo": "<string|null>" },
        "tables": { "invoiceLines": [], "visitLines": [] },
        "rawText": "<string|null>"
      }
    }
  ]
}

Rules:
- Pick exactly ONE department and ONE valid stage.
- Do not invent values or choose stages that are not listed for that department.
- FOLLOWING_UP is not a valid stage for Staffing Department.
`;

    const user = JSON.stringify({
        thread: { id: thread.id, inbox: inboxUpn, subject: thread.subject },
        messages: messagesCtx,
        attachmentsToExtract: attachmentMap.map((a) => ({
            messageGraphId: a.messageGraphId,
            graphAttachmentId: a.graphAttachmentId,
            filename: a.filename,
            contentType: a.mimeType,
            contentHash: a.contentHash,
        })),
        note: {
            pdfFileCount: pdfFiles.length,
            imageCount: images.length,
            textAttachmentCount: attachmentTexts.length,
        },
    });

    let result: ClassificationInlineResult;

    try {
        result = await openai.classifyInline<ClassificationInlineResult>({
            system,
            user,
            pdfFiles,
            images,
            attachmentTexts,
        });
    } catch (e: unknown) {
        const msg = e instanceof Error ? e.message : String(e);
        await audit(AuditAction.OPENAI_ERROR, {
            threadId,
            payload: { reason: "INLINE_CLASSIFY_FAILED", message: msg },
        });
        throw e;
    }

    assertDepartment(result.department);
    assertStage(result.department, result.stage);

    await markThreadClassified({
        threadId,
        department: result.department,
        stage: result.stage,
        needsReview: (result.confidence ?? 0) < 0.75,
    });

    await audit(AuditAction.AI_CLASSIFIED, {
        threadId,
        payload: {
            department: result.department,
            stage: result.stage,
            confidence: result.confidence,
            responseRequired: result.responseRequired ?? true,
            draftTypeSuggested: result.draftTypeSuggested ?? null,
        },
    });

    // Persist attachment extraction results
    if (Array.isArray(result.attachments)) {
        for (const out of result.attachments) {
            const match = attachmentMap.find(
                (m) => m.messageGraphId === out.messageGraphId && m.graphAttachmentId === out.graphAttachmentId
            );
            if (!match) continue;

            await prisma.attachment.update({
                where: { id: match.attachmentDbId },
                data: {
                    status: "EXTRACTED",
                    extractedJson: out.extracted ?? Prisma.JsonNull,
                    lastError: null,
                },
            });

            await audit(AuditAction.AI_EXTRACTED, {
                threadId,
                payload: {
                    messageGraphId: out.messageGraphId,
                    graphAttachmentId: out.graphAttachmentId,
                    filename: out.filename,
                },
            });
        }
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\draft.service.ts
==================================================
import { prisma } from "@/lib/db";
import { openai } from "@/lib/openai";
import { createNewMessageDraft, createReplyDraft, patchDraft } from "@/lib/graph";
import { audit } from "@/repositories/audit.repo";
import { createDraft, findLatestDraftForThread, linkGraphDraftId } from "@/repositories/draft.repo";
import { getThreadWithLatestMessage, markThreadDrafted } from "@/repositories/thread.repo";
import { DraftStatus, DraftType } from "@/domain/enums";
import { assertDraftType } from "@/domain/validators";
import { AuditAction } from "@prisma/client";

type DraftResult = {
    draftType: DraftType;
    subject: string;
    bodyHtml: string;
    to: unknown; // normalize later (OpenAI may return objects)
    cc?: unknown;
    confidence: number;
};

type ExtractedAttachmentCtx = {
    filename: string;
    mimeType: string | null;
    extractedJson: unknown | null;
};

function normalizeEmailList(input: unknown): string[] {
    const out: string[] = [];

    const push = (v: unknown) => {
        if (typeof v !== "string") return;
        const s = v.trim();
        if (!s) return;
        out.push(s);
    };

    const pullFromObj = (o: unknown) => {
        if (!o || typeof o !== "object") return;
        const r = o as Record<string, unknown>;

        // { address: "a@b.com" }
        if (typeof r.address === "string") {
            push(r.address);
            return;
        }

        // { emailAddress: { address: "a@b.com" } }
        const emailAddress = r.emailAddress;
        if (emailAddress && typeof emailAddress === "object") {
            const ea = emailAddress as Record<string, unknown>;
            if (typeof ea.address === "string") push(ea.address);
        }
    };

    if (Array.isArray(input)) {
        for (const v of input) {
            push(v);
            pullFromObj(v);
        }
    } else {
        push(input);
        pullFromObj(input);
    }

    // de-dupe
    return Array.from(new Set(out));
}

function isInvalidReplyItemError(e: unknown): boolean {
    const msg = e instanceof Error ? e.message : String(e);
    return msg.includes("Item type is invalid for creating a Reply");
}

export class DraftService {
    static async createDraftForThread(threadId: string) {
        const thread = await getThreadWithLatestMessage(threadId);
        if (!thread) return;

        // Only draft after classification step
        if (thread.processingStatus !== "CLASSIFIED") return;

        const latest = thread.messages?.[0];
        if (!latest) return;

        // If response not required, close thread
        if (thread.responseRequired === false) {
            await prisma.thread.update({
                where: { id: threadId },
                data: { processingStatus: "DONE" },
            });
            return;
        }

        // ---- Idempotency guard: if we already have a draft + graph draft id, mark drafted and stop
        const existingDraft = await findLatestDraftForThread(thread.id);
        if (existingDraft?.graphDraftMessageId) {
            await markThreadDrafted({
                threadId: thread.id,
                draftTypeSuggested: thread.draftTypeSuggested ?? existingDraft.draftType,
                responseRequired: true,
            });
            return;
        }

        // Pull extracted attachments for latest message
        const latestMsgWithAtt = await prisma.emailMessage.findUnique({
            where: { id: latest.id },
            include: { attachments: true },
        });

        const attachmentCtx: ExtractedAttachmentCtx[] =
            latestMsgWithAtt?.attachments
                .filter((a) => a.status === "EXTRACTED")
                .map((a) => ({
                    filename: a.filename,
                    mimeType: a.mimeType ?? null,
                    extractedJson: a.extractedJson ?? null,
                })) ?? [];

        // ---- Generate (or re-generate) draft text
        const result = await openai.draft<DraftResult>({
            system: `
You write professional healthcare operations email drafts.
Draft-first only. Never send.

Return JSON only with keys:
- draftType
- subject
- bodyHtml
- to
- cc
- confidence

Allowed draftType values:
EXTERNAL_REPLY
STAFFING_REQUEST_CONTACT_INFO
STAFFING_STAFFED_CONFIRMATION
CASE_MANAGEMENT_FOLLOW_UP
BILLING_FOLLOW_UP
AUTHORIZATION_FOLLOW_UP
ESCALATION_INTERNAL

Rules:
- Safe, professional, concise.
- Use extracted attachment data if present.
- No internal notes in external drafts.
- If unsure: draftType=EXTERNAL_REPLY with lower confidence.
`,
            user: JSON.stringify({
                thread: {
                    id: thread.id,
                    department: thread.department,
                    stage: thread.stage,
                    subject: thread.subject,
                    inbox: thread.inbox.emailAddress,
                },
                latestMessage: {
                    from: latest.fromJson,
                    to: latest.toJson,
                    cc: latest.ccJson,
                    subject: latest.subject,
                    preview: latest.bodyPreview,
                    bodyHtml: latest.bodyHtml,
                    bodyText: latest.bodyText,
                },
                extractedAttachments: attachmentCtx,
            }),
        });

        assertDraftType(result.draftType);

        const to = normalizeEmailList(result.to);
        const cc = normalizeEmailList(result.cc);

        // ---- Create platform draft if not exists; otherwise reuse existingDraft (avoid duplicates)
        const platformDraft =
            existingDraft ??
            (await createDraft({
                threadId: thread.id,
                draftType: result.draftType,
                status: DraftStatus.Created,
                subject: result.subject ?? null,
                bodyHtml: result.bodyHtml ?? null,
                bodyText: null,
                toJson: to,
                ccJson: cc,
                createdByUserId: null,
            }));

        // If we reused existing draft, update content so UI stays fresh
        if (existingDraft) {
            await prisma.draft.update({
                where: { id: existingDraft.id },
                data: {
                    draftType: result.draftType,
                    status: DraftStatus.Created,
                    subject: result.subject ?? null,
                    bodyHtml: result.bodyHtml ?? null,
                    toJson: to as never,
                    ccJson: cc as never,
                },
            });
        }

        await audit(AuditAction.DRAFT_CREATED, {
            threadId: thread.id,
            draftId: platformDraft.id,
            payload: { draftType: result.draftType, confidence: result.confidence },
        });

        // ---- Create Outlook draft (prefer reply, fallback to new message for non-replyable items)
        const inboxUpn = thread.inbox.emailAddress;

        let graphDraftId: string | null = null;
        let graphConversationId: string | undefined;

        try {
            const graphDraft = await createReplyDraft(inboxUpn, latest.graphMessageId, "<p></p>");
            if (!graphDraft?.id) throw new Error("Graph createReply returned no id");

            await patchDraft(inboxUpn, graphDraft.id, {
                subject: result.subject,
                bodyHtml: result.bodyHtml,
                to,
                cc,
            });

            graphDraftId = graphDraft.id;
            graphConversationId = graphDraft.conversationId;
        } catch (e: unknown) {
            if (!isInvalidReplyItemError(e)) {
                await audit(AuditAction.GRAPH_ERROR, {
                    threadId: thread.id,
                    draftId: platformDraft.id,
                    payload: { reason: "GRAPH_CREATE_REPLY_FAILED", message: e instanceof Error ? e.message : String(e) },
                });
                return;
            }

            // Fallback: create new draft message (still draft-first)
            const newDraft = await createNewMessageDraft(inboxUpn, {
                subject: result.subject,
                bodyHtml: result.bodyHtml,
                to,
                cc,
            });

            if (!newDraft?.id) {
                await audit(AuditAction.GRAPH_ERROR, {
                    threadId: thread.id,
                    draftId: platformDraft.id,
                    payload: { reason: "GRAPH_CREATE_NEW_DRAFT_FAILED" },
                });
                return;
            }

            graphDraftId = newDraft.id;
            graphConversationId = newDraft.conversationId;
        }

        // ---- Idempotent link: if link fails due to uniqueness, stop and flag review
        const linked = await linkGraphDraftId(platformDraft.id, graphDraftId);
        if (!linked) {
            await prisma.thread.update({
                where: { id: thread.id },
                data: { needsReview: true },
            });

            await audit(AuditAction.GRAPH_ERROR, {
                threadId: thread.id,
                draftId: platformDraft.id,
                payload: {
                    reason: "GRAPH_DRAFT_ID_ALREADY_LINKED",
                    graphDraftMessageId: graphDraftId,
                },
            });
            return;
        }

        await audit(AuditAction.GRAPH_CREATED_DRAFT, {
            threadId: thread.id,
            draftId: platformDraft.id,
            payload: {
                graphDraftMessageId: graphDraftId,
                conversationId: graphConversationId,
            },
        });

        await markThreadDrafted({
            threadId: thread.id,
            draftTypeSuggested: result.draftType,
            responseRequired: true,
        });

        await audit(AuditAction.AI_DRAFTED, {
            threadId: thread.id,
            draftId: platformDraft.id,
            payload: { draftType: result.draftType, confidence: result.confidence },
        });
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\draft_actions.service.ts
==================================================
import { prisma } from "@/lib/db";
import { patchDraft, sendDraft } from "@/lib/graph";
import { audit } from "@/repositories/audit.repo";
import { DraftStatus } from "@/domain/enums";
import { AuditAction } from "@prisma/client";
import { Prisma } from "@prisma/client";

type JsonInput = Prisma.InputJsonValue;
type JsonValue = Prisma.JsonValue;

function normalizeJsonEmailList(v: unknown): string[] {
    // reuse your existing normalizeEmailList logic if you want
    if (Array.isArray(v)) return v.filter((x): x is string => typeof x === "string");
    if (typeof v === "string") return [v];
    return [];
}

type EditPatch = {
    subject?: string;
    bodyHtml?: string;
    to?: string[];
    cc?: string[];
};

export class DraftActionsService {
    static async editDraft(draftId: string, actorUserId: string, patch: EditPatch) {
        const current = await prisma.draft.findUnique({
            where: { id: draftId },
            include: { thread: { include: { inbox: true } } },
        });
        if (!current) throw new Error("Draft not found");
        if (!current.thread) throw new Error("Thread not found");

        const inboxUpn = current.thread.inbox.emailAddress;

        // Find the latest version for this thread + draftType
        const latest = await prisma.draft.findFirst({
            where: { threadId: current.threadId, draftType: current.draftType },
            orderBy: [{ version: "desc" }],
        });
        if (!latest) throw new Error("Latest draft not found");

        // Ensure we have the Graph draft id on the latest row
        const graphId = latest.graphDraftMessageId;
        if (!graphId) throw new Error("Draft is not linked to an Outlook draft (graphDraftMessageId missing)");

        // Patch the Outlook draft first (if this fails, we shouldn't version bump DB)
        await patchDraft(inboxUpn, graphId, {
            subject: patch.subject,
            bodyHtml: patch.bodyHtml,
            to: patch.to,
            cc: patch.cc,
        });

        // DB versioning:
        // - move graphDraftMessageId off the previous latest row (must be null to preserve uniqueness)
        // - create a new row with version+1 holding the graphDraftMessageId
        const nextVersion = latest.version + 1;

        await prisma.$transaction(async (tx) => {
            await tx.draft.update({
                where: { id: latest.id },
                data: {
                    graphDraftMessageId: null, // critical due to @unique
                },
            });

            const toJson: JsonInput = (patch.to ?? (latest.toJson as unknown as string[])) as unknown as JsonInput;
            const ccJson: JsonInput | null =
                patch.cc ? (patch.cc as unknown as JsonInput) : (latest.ccJson as unknown as JsonInput | null);

            await tx.draft.create({
                data: {
                    threadId: latest.threadId,
                    draftType: latest.draftType,
                    status: DraftStatus.Edited,
                    version: nextVersion,
                    graphDraftMessageId: graphId,
                    subject: patch.subject ?? latest.subject,
                    bodyHtml: patch.bodyHtml ?? latest.bodyHtml,
                    bodyText: latest.bodyText,
                    toJson,
                    ccJson: ccJson ?? undefined, // prisma optional
                    createdByUserId: latest.createdByUserId,
                    lastEditedByUserId: actorUserId,
                },
            });
        });

        await audit(AuditAction.DRAFT_EDITED, {
            threadId: current.threadId,
            draftId: draftId,
            actorUserId,
            payload: { patch, nextVersion },
        });

        return { ok: true };
    }

    static async approveDraft(draftId: string, actorUserId: string) {
        const d = await prisma.draft.findUnique({
            where: { id: draftId },
            include: { thread: { include: { inbox: true } } },
        });
        if (!d) throw new Error("Draft not found");

        // Approve the latest version (safety)
        const latest = await prisma.draft.findFirst({
            where: { threadId: d.threadId, draftType: d.draftType },
            orderBy: [{ version: "desc" }],
        });
        if (!latest) throw new Error("Latest draft not found");

        await prisma.draft.update({
            where: { id: latest.id },
            data: { status: DraftStatus.Approved },
        });

        await audit(AuditAction.DRAFT_APPROVED, {
            threadId: d.threadId,
            draftId: latest.id,
            actorUserId,
            payload: {},
        });

        return { ok: true };
    }

    static async sendApprovedDraft(draftId: string, actorUserId: string) {
        const d = await prisma.draft.findUnique({
            where: { id: draftId },
            include: { thread: { include: { inbox: true } } },
        });
        if (!d) throw new Error("Draft not found");

        const latest = await prisma.draft.findFirst({
            where: { threadId: d.threadId, draftType: d.draftType },
            orderBy: [{ version: "desc" }],
        });
        if (!latest) throw new Error("Latest draft not found");
        if (latest.status !== DraftStatus.Approved) throw new Error("Draft must be APPROVED before sending");

        const graphId = latest.graphDraftMessageId;
        if (!graphId) throw new Error("graphDraftMessageId missing");

        const inboxUpn = d.thread.inbox.emailAddress;

        await sendDraft(inboxUpn, graphId);

        await prisma.$transaction(async (tx) => {
            await tx.draft.update({
                where: { id: latest.id },
                data: { status: DraftStatus.Sent },
            });

            // Ownership rule: sender becomes owner
            await tx.thread.update({
                where: { id: d.threadId },
                data: { ownerUserId: actorUserId },
            });
        });

        await audit(AuditAction.GRAPH_SENT_DRAFT, {
            threadId: d.threadId,
            draftId: latest.id,
            actorUserId,
            payload: { graphDraftMessageId: graphId },
        });

        await audit(AuditAction.DRAFT_SENT, {
            threadId: d.threadId,
            draftId: latest.id,
            actorUserId,
            payload: {},
        });

        await audit(AuditAction.OWNER_CHANGED, {
            threadId: d.threadId,
            draftId: latest.id,
            actorUserId,
            payload: { ownerUserId: actorUserId },
        });

        return { ok: true };
    }

    static async discardDraft(draftId: string, actorUserId: string) {
        const d = await prisma.draft.findUnique({ where: { id: draftId } });
        if (!d) throw new Error("Draft not found");

        const latest = await prisma.draft.findFirst({
            where: { threadId: d.threadId, draftType: d.draftType },
            orderBy: [{ version: "desc" }],
        });
        if (!latest) throw new Error("Latest draft not found");

        await prisma.draft.update({
            where: { id: latest.id },
            data: { status: DraftStatus.Discarded },
        });

        await audit(AuditAction.DRAFT_DISCARDED, {
            threadId: d.threadId,
            draftId: latest.id,
            actorUserId,
            payload: {},
        });

        return { ok: true };
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\escalation.service.ts
==================================================
import { prisma } from "@/lib/db";
import { createNewMessageDraft } from "@/lib/graph";
import { audit } from "@/repositories/audit.repo";
import {
    Department,
    DraftStatus,
    DraftType,
    ESCALATION_SUBJECT_PREFIX,
} from "@/domain/enums";
import { AuditAction } from "@prisma/client";

type TriggerEscalationArgs = {
    threadId: string;
    reason: string;
    actorUserId?: string | null;
};

function getEscalationInbox(department: string) {
    switch (department) {
        case Department.Staffing:
            return "staffing@therapydepotonline.com";
        case Department.CaseManagement:
            return "services@therapydepotonline.com";
        case Department.Billing:
            return "billing@therapydepotonline.com";
        default:
            throw new Error(`No escalation inbox for department: ${department}`);
    }
}

export class EscalationService {
    static async triggerEscalation(args: TriggerEscalationArgs) {
        const thread = await prisma.thread.findUnique({
            where: { id: args.threadId },
            include: {
                inbox: true,
                messages: { orderBy: { receivedAt: "desc" }, take: 1 },
            },
        });
        if (!thread) throw new Error("Thread not found");

        const escalationInbox = getEscalationInbox(thread.department);

        const existing = await prisma.escalation.findFirst({
            where: { threadId: thread.id, department: thread.department },
        });
        if (existing) return { ok: true, skipped: true };

        const latestMessage = thread.messages[0];

        const subject = `${ESCALATION_SUBJECT_PREFIX} ${thread.subject ?? "No subject"}`;

        const bodyHtml = `
      <p><strong>Escalation Reason:</strong> ${args.reason}</p>
      <p><strong>Department:</strong> ${thread.department}</p>
      <p><strong>Stage:</strong> ${thread.stage}</p>
      <p><strong>Original Inbox:</strong> ${thread.inbox.emailAddress}</p>
      <hr />
      <p><strong>Latest Message Preview:</strong></p>
      <blockquote>${latestMessage?.bodyPreview ?? "N/A"}</blockquote>
    `;

        const actorUserId = args.actorUserId ?? undefined;

        // 1) Create platform draft (avoid nulls in prisma input)
        const draft = await prisma.draft.create({
            data: {
                threadId: thread.id,
                draftType: DraftType.EscalationInternal,
                status: DraftStatus.Created,
                version: 1,
                subject,
                bodyHtml,
                // bodyText: undefined, // omit
                toJson: [escalationInbox],
                // ccJson: undefined,  // omit
                createdByUserId: actorUserId,
                // lastEditedByUserId: undefined,
            },
        });

        // 2) Create Graph draft in escalation inbox
        const graphDraft = await createNewMessageDraft(escalationInbox, {
            subject,
            bodyHtml,
            to: [escalationInbox],
        });

        if (!graphDraft?.id) {
            await audit(AuditAction.GRAPH_ERROR, {
                threadId: thread.id,
                draftId: draft.id,
                actorUserId,
                payload: { reason: "ESCALATION_GRAPH_DRAFT_FAILED" },
            });
            return { ok: false };
        }

        await prisma.draft.update({
            where: { id: draft.id },
            data: { graphDraftMessageId: graphDraft.id },
        });

        const escalation = await prisma.escalation.create({
            data: {
                threadId: thread.id,
                department: thread.department,
                reason: args.reason,
                draftId: draft.id,
            },
        });

        await audit(AuditAction.ESCALATION_TRIGGERED, {
            threadId: thread.id,
            draftId: draft.id,
            actorUserId,
            payload: {
                escalationId: escalation.id,
                department: thread.department,
                inbox: escalationInbox,
            },
        });

        await audit(AuditAction.GRAPH_CREATED_DRAFT, {
            threadId: thread.id,
            draftId: draft.id,
            actorUserId,
            payload: { graphDraftMessageId: graphDraft.id, escalationInbox },
        });

        return { ok: true };
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\extraction.service.ts
==================================================
import { prisma } from "@/lib/db";
import { downloadAttachmentContent } from "@/lib/graph";
import { openai } from "@/lib/openai";
import { audit } from "@/repositories/audit.repo";
import { AuditAction, Prisma } from "@prisma/client";

type ExtractResult = {
    extracted: unknown; // or Prisma.JsonValue if you want stricter JSON typing
    confidence: number;
};

function errorToMessage(e: unknown): string {
    if (e instanceof Error) return e.message;
    return typeof e === "string" ? e : JSON.stringify(e);
}

export class ExtractionService {
    static async processAttachment(attachmentId: string) {
        const att = await prisma.attachment.findUnique({
            where: { id: attachmentId },
            include: {
                message: {
                    include: {
                        thread: { include: { inbox: true } },
                    },
                },
            },
        });

        if (!att || att.status !== "PENDING") return;

        const inboxUpn = att.message.thread.inbox.emailAddress;

        try {
            const file = await downloadAttachmentContent(
                inboxUpn,
                att.message.graphMessageId,
                att.graphAttachmentId
            );

            // Use the method your wrapper actually has
            const result = await openai.classifyInline<ExtractResult>({
                system: `
You extract structured data from healthcare documents.
Return JSON only with keys: extracted, confidence.
If you cannot extract, return extracted = null and confidence low.
`,
                user: JSON.stringify({
                    filename: file.name,
                    contentType: file.contentType,
                    note: "Attachment bytes downloaded. Routed content provided separately.",
                }),
                pdfFiles: [],
                images: [],
                attachmentTexts: [],
            });


            // Prisma Json fields: avoid "as any"; use Prisma.InputJsonValue / Prisma.JsonNull
            const extractedJson: Prisma.InputJsonValue = {
                placeholder: true,
                filename: file.name,
                contentType: file.contentType,
                sizeBytes: file.bytes.length,
                extracted: (result.extracted ?? null) as Prisma.InputJsonValue,
                confidence: result.confidence,
            };

            await prisma.attachment.update({
                where: { id: att.id },
                data: {
                    status: "EXTRACTED",
                    extractedJson, // or extractedJson: extractedJson ?? Prisma.JsonNull (depending on your schema)
                    lastError: null,
                },
            });

            await audit(AuditAction.AI_EXTRACTED, {
                threadId: att.message.threadId,
                messageId: att.messageId,
                payload: { attachmentId: att.id, filename: file.name },
            });
        } catch (e: unknown) {
            const msg = errorToMessage(e);

            await prisma.attachment.update({
                where: { id: att.id },
                data: {
                    status: "FAILED",
                    lastError: msg,
                },
            });

            await audit(AuditAction.GRAPH_ERROR, {
                threadId: att.message.threadId,
                messageId: att.messageId,
                payload: { attachmentId: att.id, error: msg },
            });
        }
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\ingestion.service.ts
==================================================
import {
    fetchDeltaAll,
    fetchDeltaAllFrom,
    getMessage,
    listMessageAttachments,
    type GraphAttachmentListItem,
} from "@/lib/graph";
import {
    getAllSharedInboxes,
    getInboxCursor,
    upsertInboxCursor,
} from "@/repositories/inbox.repo";
import { upsertThread } from "@/repositories/thread.repo";
import { upsertMessage } from "@/repositories/message.repo";
import { upsertAttachment } from "@/repositories/attachment.repo";
import { audit } from "@/repositories/audit.repo";
import { AuditAction, Prisma } from "@prisma/client";

function toDate(s?: string | null) {
    if (!s) return null;
    const d = new Date(s);
    return Number.isNaN(d.getTime()) ? null : d;
}

// Optional env: limit initial backfill only (when no delta cursor yet)
function getLookbackDays(): number | null {
    const raw = process.env.GRAPH_INGEST_LOOKBACK_DAYS;
    if (!raw) return null;
    const n = Number(raw);
    if (!Number.isFinite(n) || n <= 0) return null;
    return Math.floor(n);
}

function isoDaysAgo(days: number): string {
    const d = new Date();
    d.setUTCDate(d.getUTCDate() - days);
    return d.toISOString();
}

// Graph SDK types are not JSON-typed, but they are JSON-serializable.
// This helper forces correct Prisma JSON input types.
function asJson(v: unknown): Prisma.InputJsonValue {
    return v as Prisma.InputJsonValue;
}

export class IngestionService {
    static async runOnce() {
        const inboxes = await getAllSharedInboxes();
        const lookbackDays = getLookbackDays();

        for (const inbox of inboxes) {
            const cursor = await getInboxCursor(inbox.id);

            // IMPORTANT:
            // - If we already have a deltaLink, always use it (incremental).
            // - Only apply lookback on FIRST sync (no cursor yet).
            // - Always page through @odata.nextLink and persist ONLY final @odata.deltaLink.
            const { items, deltaLink } = cursor?.deltaLink
                ? await fetchDeltaAll(inbox.emailAddress, cursor.deltaLink)
                : lookbackDays
                    ? await fetchDeltaAllFrom(inbox.emailAddress, isoDaysAgo(lookbackDays))
                    : await fetchDeltaAll(inbox.emailAddress, null);

            for (const item of items) {
                if (!item?.id || !item?.conversationId) continue;

                // Fetch full message (body, recipients, etc.)
                const msg = await getMessage(inbox.emailAddress, item.id);
                if (!msg?.conversationId) continue;

                const thread = await upsertThread({
                    inboxId: inbox.id,
                    graphConversationId: msg.conversationId,
                    subject: msg.subject ?? null,
                    lastMessageAt: toDate(msg.receivedDateTime) ?? null,
                });

                const storedMsg = await upsertMessage({
                    threadId: thread.id,
                    graphMessageId: msg.id,
                    internetMessageId: msg.internetMessageId ?? null,

                    // JSON fields (Prisma): do not pass plain null for Json inputs
                    fromJson: msg.from ? asJson(msg.from) : Prisma.JsonNull,
                    toJson: asJson(msg.toRecipients ?? []),
                    ccJson: asJson(msg.ccRecipients ?? []),

                    subject: msg.subject ?? null,
                    bodyPreview: msg.bodyPreview ?? null,
                    bodyHtml:
                        msg.body?.contentType?.toLowerCase?.() === "html"
                            ? msg.body?.content ?? null
                            : null,
                    bodyText:
                        msg.body?.contentType?.toLowerCase?.() === "text"
                            ? msg.body?.content ?? null
                            : null,

                    receivedAt: toDate(msg.receivedDateTime),
                    sentAt: toDate(msg.sentDateTime),

                    hasAttachments: !!msg.hasAttachments,
                });

                await audit(AuditAction.GRAPH_INGESTED_MESSAGE, {
                    threadId: thread.id,
                    messageId: storedMsg.id,
                    payload: {
                        inbox: inbox.emailAddress,
                        graphMessageId: msg.id,
                        conversationId: msg.conversationId,
                    },
                });

                if (msg.hasAttachments) {
                    const att = await listMessageAttachments(inbox.emailAddress, msg.id);
                    const attachments: GraphAttachmentListItem[] = att.value ?? [];

                    for (const a of attachments) {
                        if (!a.id || !a.name) continue;

                        await upsertAttachment({
                            messageId: storedMsg.id,
                            graphAttachmentId: a.id,
                            filename: a.name,
                            mimeType: a.contentType ?? null,
                            sizeBytes: typeof a.size === "number" ? a.size : null,
                        });
                    }
                }
            }

            // Persist ONLY the final deltaLink (if present)
            if (deltaLink) {
                await upsertInboxCursor(inbox.id, deltaLink);
            }
        }
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\services\stage.service.ts
==================================================
import { prisma } from "@/lib/db";
import { audit } from "@/repositories/audit.repo";
import { AuditAction } from "@prisma/client";
import { Department, isValidStageForDepartment } from "@/domain/enums";

export class StageService {
    static async changeStage(args: { threadId: string; stage: string; actorUserId: string }) {
        const thread = await prisma.thread.findUnique({ where: { id: args.threadId } });
        if (!thread) throw new Error("Thread not found");

        // Only allow stage change within current department (safe without UI/auth)
        const department = thread.department as Department; // not any
        if (!Object.values(Department).includes(department)) {
            throw new Error(`Invalid department on thread: ${thread.department}`);
        }

        if (!isValidStageForDepartment(department, args.stage)) {
            throw new Error(`Invalid stage '${args.stage}' for department '${department}'`);
        }

        await prisma.$transaction(async (tx) => {
            await tx.thread.update({
                where: { id: args.threadId },
                data: {
                    stage: args.stage,
                    ownerUserId: args.actorUserId,
                },
            });
        });

        await audit(AuditAction.STAGE_CHANGED, {
            threadId: args.threadId,
            actorUserId: args.actorUserId,
            payload: { stage: args.stage },
        });

        await audit(AuditAction.OWNER_CHANGED, {
            threadId: args.threadId,
            actorUserId: args.actorUserId,
            payload: { ownerUserId: args.actorUserId },
        });

        return { ok: true };
    }
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\src\utils\correlation.ts
==================================================



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\workers\classify.worker.ts
==================================================
import "dotenv/config";
import { prisma } from "@/lib/db";
import { classifyThread } from "@/services/classification.service";

async function sleep(ms: number) {
    return new Promise((r) => setTimeout(r, ms));
}

async function main() {
    for (;;) {
        try {
            const threads = await prisma.thread.findMany({
                where: { processingStatus: "NEW" },
                orderBy: { createdAt: "asc" },
                take: 10,
            });

            for (const thread of threads) {
                await classifyThread(thread.id);
            }
        } catch (e: unknown) {
            if (e instanceof Error) {
                console.error("[classify] error", e.message);
            } else {
                console.error("[classify] error", e);
            }
        }
        await sleep(10_000);
    }
}

main();



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\workers\draft.worker.ts
==================================================
import "dotenv/config";
import { prisma } from "@/lib/db";
import { DraftService } from "@/services/draft.service";

async function sleep(ms: number) {
    return new Promise((r) => setTimeout(r, ms));
}

async function main() {
    for (;;) {
        try {
            const threads = await prisma.thread.findMany({
                where: {
                    processingStatus: "CLASSIFIED",
                    needsReview: false,
                    drafts: { none: {} }, // <--- key line
                },
                orderBy: { updatedAt: "asc" },
                take: 10,
                select: { id: true },
            });
            for (const t of threads) {
                await DraftService.createDraftForThread(t.id);
            }
        } catch (e: unknown) {
            if (e instanceof Error) {
                console.error("[draft] error", e.message);
            } else {
                console.error("[draft] error", e);
            }
        }

        await sleep(10_000);
    }
}

main();



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\workers\ingest.worker.ts
==================================================
import "dotenv/config";
import { IngestionService } from "@/services/ingestion.service";

async function sleep(ms: number) {
    return new Promise((r) => setTimeout(r, ms));
}

function errorToMessage(e: unknown): string {
    if (e instanceof Error) return e.message;
    return typeof e === "string" ? e : JSON.stringify(e);
}

async function main() {
    // simple loop for dev
    for (;;) {
        try {
            await IngestionService.runOnce();
            // eslint-disable-next-line no-console
            console.log(`[ingest] ok @ ${new Date().toISOString()}`);
        } catch (e: unknown) {
            // eslint-disable-next-line no-console
            console.error("[ingest] error", errorToMessage(e));
        }
        await sleep(30_000);
    }
}

main();



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\prisma\migrations\20260105170034_init\migration.sql
==================================================
-- CreateTable
CREATE TABLE `User` (
    `id` VARCHAR(191) NOT NULL,
    `email` VARCHAR(191) NOT NULL,
    `displayName` VARCHAR(191) NULL,
    `initials` VARCHAR(191) NOT NULL,
    `role` ENUM('ADMIN', 'USER') NOT NULL DEFAULT 'USER',
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `User_email_key`(`email`),
    UNIQUE INDEX `User_initials_key`(`initials`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Inbox` (
    `id` VARCHAR(191) NOT NULL,
    `key` VARCHAR(191) NOT NULL,
    `emailAddress` VARCHAR(191) NOT NULL,
    `isEscalation` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `Inbox_key_key`(`key`),
    UNIQUE INDEX `Inbox_emailAddress_isEscalation_key`(`emailAddress`, `isEscalation`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `InboxCursor` (
    `id` VARCHAR(191) NOT NULL,
    `inboxId` VARCHAR(191) NOT NULL,
    `deltaLink` LONGTEXT NULL,
    `lastSyncAt` DATETIME(3) NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `InboxCursor_inboxId_key`(`inboxId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Thread` (
    `id` VARCHAR(191) NOT NULL,
    `inboxId` VARCHAR(191) NOT NULL,
    `graphConversationId` VARCHAR(191) NOT NULL,
    `subject` VARCHAR(191) NULL,
    `lastMessageAt` DATETIME(3) NULL,
    `department` VARCHAR(191) NOT NULL,
    `stage` VARCHAR(191) NOT NULL,
    `needsReview` BOOLEAN NOT NULL DEFAULT false,
    `responseRequired` BOOLEAN NOT NULL DEFAULT true,
    `draftTypeSuggested` VARCHAR(191) NULL,
    `ownerUserId` VARCHAR(191) NULL,
    `processingStatus` ENUM('NEW', 'CLASSIFIED', 'DRAFTED', 'DONE', 'FAILED') NOT NULL DEFAULT 'NEW',
    `slaDueAt` DATETIME(3) NULL,
    `slaBreachedAt` DATETIME(3) NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    INDEX `Thread_department_idx`(`department`),
    INDEX `Thread_stage_idx`(`stage`),
    INDEX `Thread_ownerUserId_idx`(`ownerUserId`),
    INDEX `Thread_slaDueAt_idx`(`slaDueAt`),
    INDEX `Thread_processingStatus_idx`(`processingStatus`),
    UNIQUE INDEX `Thread_inboxId_graphConversationId_key`(`inboxId`, `graphConversationId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `EmailMessage` (
    `id` VARCHAR(191) NOT NULL,
    `threadId` VARCHAR(191) NOT NULL,
    `graphMessageId` VARCHAR(191) NOT NULL,
    `internetMessageId` VARCHAR(191) NULL,
    `fromJson` JSON NOT NULL,
    `toJson` JSON NOT NULL,
    `ccJson` JSON NULL,
    `sentAt` DATETIME(3) NULL,
    `receivedAt` DATETIME(3) NULL,
    `subject` VARCHAR(191) NULL,
    `bodyPreview` LONGTEXT NULL,
    `bodyHtml` LONGTEXT NULL,
    `bodyText` LONGTEXT NULL,
    `hasAttachments` BOOLEAN NOT NULL DEFAULT false,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `EmailMessage_graphMessageId_key`(`graphMessageId`),
    INDEX `EmailMessage_threadId_idx`(`threadId`),
    INDEX `EmailMessage_receivedAt_idx`(`receivedAt`),
    INDEX `EmailMessage_internetMessageId_idx`(`internetMessageId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Attachment` (
    `id` VARCHAR(191) NOT NULL,
    `messageId` VARCHAR(191) NOT NULL,
    `graphAttachmentId` VARCHAR(191) NOT NULL,
    `filename` VARCHAR(191) NOT NULL,
    `mimeType` VARCHAR(191) NULL,
    `sizeBytes` INTEGER NULL,
    `contentHash` VARCHAR(191) NULL,
    `status` ENUM('PENDING', 'EXTRACTED', 'FAILED') NOT NULL DEFAULT 'PENDING',
    `extractedJson` JSON NULL,
    `lastError` LONGTEXT NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    INDEX `Attachment_status_idx`(`status`),
    UNIQUE INDEX `Attachment_messageId_graphAttachmentId_key`(`messageId`, `graphAttachmentId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Draft` (
    `id` VARCHAR(191) NOT NULL,
    `threadId` VARCHAR(191) NOT NULL,
    `draftType` VARCHAR(191) NOT NULL,
    `status` VARCHAR(191) NOT NULL,
    `version` INTEGER NOT NULL DEFAULT 1,
    `graphDraftMessageId` VARCHAR(191) NULL,
    `subject` VARCHAR(191) NULL,
    `toJson` JSON NOT NULL,
    `ccJson` JSON NULL,
    `bodyHtml` LONGTEXT NULL,
    `bodyText` LONGTEXT NULL,
    `createdByUserId` VARCHAR(191) NULL,
    `lastEditedByUserId` VARCHAR(191) NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    UNIQUE INDEX `uq_draft_graph_message_id`(`graphDraftMessageId`),
    INDEX `Draft_threadId_idx`(`threadId`),
    INDEX `Draft_status_idx`(`status`),
    INDEX `Draft_draftType_idx`(`draftType`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Escalation` (
    `id` VARCHAR(191) NOT NULL,
    `threadId` VARCHAR(191) NOT NULL,
    `department` VARCHAR(191) NOT NULL,
    `reason` VARCHAR(191) NOT NULL,
    `triggeredAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `draftId` VARCHAR(191) NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    `updatedAt` DATETIME(3) NOT NULL,

    INDEX `Escalation_threadId_idx`(`threadId`),
    INDEX `Escalation_department_idx`(`department`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `AuditLog` (
    `id` VARCHAR(191) NOT NULL,
    `threadId` VARCHAR(191) NULL,
    `messageId` VARCHAR(191) NULL,
    `draftId` VARCHAR(191) NULL,
    `actorUserId` VARCHAR(191) NULL,
    `action` ENUM('AI_CLASSIFIED', 'AI_DRAFTED', 'AI_EXTRACTED', 'STAGE_CHANGED', 'OWNER_CHANGED', 'DRAFT_CREATED', 'DRAFT_EDITED', 'DRAFT_APPROVED', 'DRAFT_SENT', 'DRAFT_DISCARDED', 'ESCALATION_TRIGGERED', 'GRAPH_INGESTED_MESSAGE', 'GRAPH_CREATED_DRAFT', 'GRAPH_SENT_DRAFT', 'GRAPH_ERROR', 'OPENAI_ERROR') NOT NULL,
    `payload` JSON NULL,
    `createdAt` DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),

    INDEX `AuditLog_threadId_idx`(`threadId`),
    INDEX `AuditLog_messageId_idx`(`messageId`),
    INDEX `AuditLog_draftId_idx`(`draftId`),
    INDEX `AuditLog_actorUserId_idx`(`actorUserId`),
    INDEX `AuditLog_action_idx`(`action`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `InboxCursor` ADD CONSTRAINT `InboxCursor_inboxId_fkey` FOREIGN KEY (`inboxId`) REFERENCES `Inbox`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Thread` ADD CONSTRAINT `Thread_inboxId_fkey` FOREIGN KEY (`inboxId`) REFERENCES `Inbox`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Thread` ADD CONSTRAINT `Thread_ownerUserId_fkey` FOREIGN KEY (`ownerUserId`) REFERENCES `User`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `EmailMessage` ADD CONSTRAINT `EmailMessage_threadId_fkey` FOREIGN KEY (`threadId`) REFERENCES `Thread`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Attachment` ADD CONSTRAINT `Attachment_messageId_fkey` FOREIGN KEY (`messageId`) REFERENCES `EmailMessage`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Draft` ADD CONSTRAINT `fk_draft_thread` FOREIGN KEY (`threadId`) REFERENCES `Thread`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Draft` ADD CONSTRAINT `fk_draft_created_by` FOREIGN KEY (`createdByUserId`) REFERENCES `User`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Draft` ADD CONSTRAINT `fk_draft_last_edited_by` FOREIGN KEY (`lastEditedByUserId`) REFERENCES `User`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Escalation` ADD CONSTRAINT `Escalation_threadId_fkey` FOREIGN KEY (`threadId`) REFERENCES `Thread`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `Escalation` ADD CONSTRAINT `Escalation_draftId_fkey` FOREIGN KEY (`draftId`) REFERENCES `Draft`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `AuditLog` ADD CONSTRAINT `AuditLog_threadId_fkey` FOREIGN KEY (`threadId`) REFERENCES `Thread`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `AuditLog` ADD CONSTRAINT `AuditLog_messageId_fkey` FOREIGN KEY (`messageId`) REFERENCES `EmailMessage`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `AuditLog` ADD CONSTRAINT `AuditLog_draftId_fkey` FOREIGN KEY (`draftId`) REFERENCES `Draft`(`id`) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE `AuditLog` ADD CONSTRAINT `AuditLog_actorUserId_fkey` FOREIGN KEY (`actorUserId`) REFERENCES `User`(`id`) ON DELETE SET NULL ON UPDATE CASCADE;



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\prisma\migrations\20260106182128_sync\migration.sql
==================================================
-- DropIndex
DROP INDEX `EmailMessage_internetMessageId_idx` ON `emailmessage`;

-- AlterTable
ALTER TABLE `emailmessage` MODIFY `internetMessageId` LONGTEXT NULL;



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\prisma\migrations\migration_lock.toml
==================================================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "mysql"



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\prisma\schema.prisma
==================================================
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
}

/**
 * Users and roles
 */
enum UserRole {
  ADMIN
  USER
}

/**
 * Processing state for pipeline orchestration
 */
enum ThreadProcessingStatus {
  NEW
  CLASSIFIED
  DRAFTED
  DONE
  FAILED
}

/**
 * Attachment extraction state (no skipping, but failures are tracked)
 */
enum AttachmentStatus {
  PENDING
  EXTRACTED
  FAILED
}

/**
 * Audit actions (append-only)
 */
enum AuditAction {
  AI_CLASSIFIED
  AI_DRAFTED
  AI_EXTRACTED

  STAGE_CHANGED
  OWNER_CHANGED

  DRAFT_CREATED
  DRAFT_EDITED
  DRAFT_APPROVED
  DRAFT_SENT
  DRAFT_DISCARDED

  ESCALATION_TRIGGERED

  GRAPH_INGESTED_MESSAGE
  GRAPH_CREATED_DRAFT
  GRAPH_SENT_DRAFT
  GRAPH_ERROR
  OPENAI_ERROR
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  displayName String?
  initials    String   @unique
  role        UserRole @default(USER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ownedThreads   Thread[] @relation("ThreadOwner")
  createdDrafts  Draft[]  @relation("DraftCreatedBy")
  editedDrafts   Draft[]  @relation("DraftEditedBy")
  auditEvents    AuditLog[]
}

model Inbox {
  id           String  @id @default(cuid())
  key          String  @unique
  emailAddress String
  isEscalation Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  threads Thread[]
  cursor  InboxCursor?

  @@unique([emailAddress, isEscalation])
}

model InboxCursor {
  id        String @id @default(cuid())
  inboxId   String @unique
  inbox     Inbox  @relation(fields: [inboxId], references: [id], onDelete: Cascade)

  deltaLink String?  @db.LongText
  lastSyncAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Thread {
  id                 String @id @default(cuid())
  inboxId            String
  inbox              Inbox  @relation(fields: [inboxId], references: [id], onDelete: Cascade)

  graphConversationId String
  subject            String?
  lastMessageAt      DateTime?

  // Scope: exactly one department per email/thread
  department         String // validated against src/domain/enums.ts Department
  stage              String // validated against STAGES_BY_DEPARTMENT
  needsReview        Boolean @default(false)

  responseRequired   Boolean @default(true)
  draftTypeSuggested String? // DraftType enum value suggested by AI

  ownerUserId        String?
  owner              User?   @relation("ThreadOwner", fields: [ownerUserId], references: [id], onDelete: SetNull)

  processingStatus   ThreadProcessingStatus @default(NEW)

  // SLA
  slaDueAt           DateTime?
  slaBreachedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages     EmailMessage[]
  drafts       Draft[]
  escalations  Escalation[]
  auditLogs    AuditLog[]

  @@unique([inboxId, graphConversationId])
  @@index([department])
  @@index([stage])
  @@index([ownerUserId])
  @@index([slaDueAt])
  @@index([processingStatus])
}

model EmailMessage {
  id              String @id @default(cuid())
  threadId        String
  thread          Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  graphMessageId      String @unique
  internetMessageId   String? @db.LongText

  fromJson         Json
  toJson           Json
  ccJson           Json?

  sentAt           DateTime?
  receivedAt       DateTime?

  subject          String?
  bodyPreview      String? @db.LongText
  bodyHtml         String? @db.LongText
  bodyText         String? @db.LongText

  hasAttachments   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  attachments Attachment[]
  auditLogs   AuditLog[]

  @@index([threadId])
  @@index([receivedAt])
}

model Attachment {
  id                String @id @default(cuid())
  messageId          String
  message            EmailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  graphAttachmentId  String
  filename           String
  mimeType           String?
  sizeBytes          Int?

  // for idempotency
  contentHash        String?

  status             AttachmentStatus @default(PENDING)
  extractedJson      Json?
  lastError          String? @db.LongText

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([messageId, graphAttachmentId])
  @@index([status])
}

model Draft {
  id                 String @id @default(cuid())
  threadId            String
  thread              Thread @relation(fields: [threadId], references: [id], onDelete: Cascade, map: "fk_draft_thread")

  draftType           String  // validated against DraftType in enums.ts
  status              String  // validated against DraftStatus in enums.ts

  version             Int @default(1)

  // Outlook draft id (Graph message id for the draft)
  graphDraftMessageId String? @unique(map: "uq_draft_graph_message_id")

  subject             String?
  toJson              Json
  ccJson              Json?
  bodyHtml            String? @db.LongText
  bodyText            String? @db.LongText

  createdByUserId     String?
  createdBy           User? @relation("DraftCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull, map: "fk_draft_created_by")

  lastEditedByUserId  String?
  lastEditedBy        User? @relation("DraftEditedBy", fields: [lastEditedByUserId], references: [id], onDelete: SetNull, map: "fk_draft_last_edited_by")

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  auditLogs           AuditLog[]
  escalations         Escalation[]

  // IMPORTANT: remove @@unique([graphDraftMessageId]) because @unique already exists above
  @@index([threadId])
  @@index([status])
  @@index([draftType])
}


model Escalation {
  id          String @id @default(cuid())
  threadId     String
  thread       Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  department   String // Department enum validated in app
  reason       String
  triggeredAt  DateTime @default(now())

  draftId      String?
  draft        Draft? @relation(fields: [draftId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([threadId])
  @@index([department])
}

model AuditLog {
  id          String @id @default(cuid())

  threadId    String?
  thread      Thread? @relation(fields: [threadId], references: [id], onDelete: Cascade)

  messageId   String?
  message     EmailMessage? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  draftId     String?
  draft       Draft? @relation(fields: [draftId], references: [id], onDelete: Cascade)

  actorUserId String?
  actor       User? @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  action      AuditAction
  payload     Json?

  createdAt DateTime @default(now())

  @@index([threadId])
  @@index([messageId])
  @@index([draftId])
  @@index([actorUserId])
  @@index([action])
}



==================================================
FILE: C:\Users\abdur\WebstormProjects\william\prisma\seed.ts
==================================================
import "dotenv/config";
import { PrismaClient } from "@prisma/client";
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const adapter = new PrismaMariaDb(process.env.DATABASE_URL!);
export const prisma = new PrismaClient({ adapter });

function makeKey(prefix: string, email: string, maxLen: number) {
    return (prefix + email)
        .toUpperCase()
        .replace(/[^A-Z0-9]+/g, "_")
        .slice(0, maxLen);
}

async function main() {
    await prisma.user.deleteMany({ where: { email: "admin@local" } });

    // 1) Admin user
    await prisma.user.upsert({
        where: { email: "admin@tdp.com" },
        update: {
            displayName: "Admin",
            initials: "AD",
            role: "ADMIN",
        },
        create: {
            email: "admin@tdp.com",
            displayName: "Admin",
            initials: "AD",
            role: "ADMIN",
        },
    });

    // 2) Shared inboxes (operational)
    const sharedInboxes = (process.env.GRAPH_SHARED_INBOXES || "")
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean);

    for (const email of sharedInboxes) {
        const key = makeKey("", email, 40);

        await prisma.inbox.upsert({
            where: {
                // requires @@unique([emailAddress, isEscalation]) in Prisma schema
                emailAddress_isEscalation: { emailAddress: email, isEscalation: false },
            },
            update: {
                key,
                emailAddress: email,
                isEscalation: false,
            },
            create: {
                key,
                emailAddress: email,
                isEscalation: false,
            },
        });
    }

    // 3) Escalation inboxes (internal-only targets)
    const escalation = [
        process.env.GRAPH_ESCALATION_STAFFING,
        process.env.GRAPH_ESCALATION_SERVICES,
        process.env.GRAPH_ESCALATION_BILLING,
    ].filter(Boolean) as string[];

    for (const email of escalation) {
        const key = makeKey("ESCALATION_", email, 60);

        await prisma.inbox.upsert({
            where: {
                // requires @@unique([emailAddress, isEscalation]) in Prisma schema
                emailAddress_isEscalation: { emailAddress: email, isEscalation: true },
            },
            update: {
                key,
                emailAddress: email,
                isEscalation: true,
            },
            create: {
                key,
                emailAddress: email,
                isEscalation: true,
            },
        });
    }
}

main()
    .then(async () => prisma.$disconnect())
    .catch(async (e) => {
        console.error(e);
        await prisma.$disconnect();
        process.exit(1);
    });



